---
title: "Post_GMM_Analysis"
format: pdf
editor: visual
---

```{r libraries}
library(tidyverse)
library(stringr) 

```

```{r directories}
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/07_Enrichment_analysis_custom_background_Sets/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/07_Enrichment_analysis_custom_background_Sets/in/"
gc()
```

```{r logic_outline}

# 



```

## Get proportion of tyrosine-containing peptides

For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)

```{r read_data, echo=FALSE}
# specify the extension unique to your calibrated files
extension = "postGMM"

# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)

# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)

# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list. 
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
  print(bin_data_files[[i]])
  postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
  print(i/length(input_filenames)*100)
}

# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
```

```{r clean_names}
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe

# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)

# Now, cleaned_names should have the format like 'mz_0.300-0.400' 

# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()


# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))

names(postGMM_data) <- cleaned_names

```

## Data Cleaning for enrichment analysis using cluster profiler

```{r data_preclean}
# we need to clean the read in data as it contains python chaacters (e.g. [] for a list)
# rm(cleaned_postGMM_data, test)
gc()
cleaned_postGMM_data <- list()
for (i in 1:length(postGMM_data)) {
  
  cleaned_postGMM_data[[i]] <- clean_data(postGMM_data[[i]])
  print(i/length(postGMM_data))
  
}

names(cleaned_postGMM_data) <- names(postGMM_data)

```

```{r Prefiltering_of_Tyrosine_containing_only}
## for all data we are only interested in the tyrosinde containing peptidoforms 

# this is the bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_-0.0125_-0.0075"]]

# for our foreground we only really want phosphotyrosine-containing peptides in 
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a 
# phosphotyrosine because some phosphogroups assigned to be positionally on a 
# Threonine or Serine might actually be on a Tyrosine. 
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
# Save as a TSV file
write.table(tyrosines_containing_foreground, file = paste0(project_dir,"out/mz_-0.0125_-0.0075_tyrosine_containing_foreground.tsv"), sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)

# the remaining bins can be used as decoy bins; use the same filtering
# Initialize the list to store decoy bins
DECOY_bins_list <- list()

# Iterate through the list of dataframes (cleaned_postGMM_data)
for (bin_name in names(cleaned_postGMM_data)) {
    # Skip the bin of interest
    if (bin_name == "mz_-0.0125_-0.0075") {
        next
    }
  
    # Get the current bin
    current_bin <- cleaned_postGMM_data[[bin_name]]
  
    # Filter for tyrosine-containing peptides
    tyrosines_containing_bin <- current_bin[grepl("Y", current_bin$peptidoform_id), ]
  
    
    # Save as a TSV file
    write.table(tyrosines_containing_bin, 
                file = paste0(project_dir,"out/DECOY", bin_name, "_tyrosine_containing_foreground.tsv"), 
                sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)
    
    
    # Append to the decoy bins list
    DECOY_bins_list[[bin_name]] <- tyrosines_containing_bin
}

# for background we only want tyrosines but from across ALL bins, including bin of interest
# first get all bin data together and only keep unique rows (as some peptidoforms that could have bi or trimodal distribution may be captured in multiple bins)
tyrosines_containing_background <- bind_rows(cleaned_postGMM_data) %>% distinct()

# filter down to only include phosphotyrosine-containing peptides
tyrosines_containing_background <- tyrosines_containing_background[grepl("Y", tyrosines_containing_background$peptidoform_id), ]

# save 
write.table(tyrosines_containing_background, file = paste0(project_dir,"out/tyrosine_containing_background.tsv"), 
            sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)


```

```{r proteinID_foreground}
# run cleaning to retain SwissProt entry only
# Split Swiss_Prot_Human$neXtProt and Swiss_Prot_Human$RefSeq into lists of IDs
  # Apply the split_ids function I wrote; we will need these 
  neXtProt_list <- lapply(Swiss_Prot_Human$neXtProt, split_ids)
  RefSeq_list <- lapply(Swiss_Prot_Human$RefSeq, split_ids)


# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))

# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)

# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)

# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry 
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
#### this does not

# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))

tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_foreground_inSwissProt, file = "../out/tyrosine_containing_foreground_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# also write the ones with no hit
tyrosines_containing_foreground_UNMATCHED <- tyrosines_containing_foreground[!tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]


write.table(tyrosines_containing_foreground_UNMATCHED, file = "../out/tyrosine_containing_foreground_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)



```

```{r proteinID_background}

# first generate a list of lists with the background IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
background_id_list <- lapply(strsplit(tyrosines_containing_background$protein, ", "), function(x) unlist(strsplit(x, ", ")))

# clean them up to be able to match bakc to SwissProt library
clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)

# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)

# process each sublist in background_cleaned_IDs to return the SwissProt Entry 
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)


# Flatten the background_cleaned_IDs list to then add to our data frame
flattened_background_cleaned_IDs <- sapply(background_cleaned_IDs, function(x) paste(x, collapse = ","))

tyrosines_containing_background$cleaned_protein_IDs <- flattened_background_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_background_inSwissProt <- tyrosines_containing_background[tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_background_inSwissProt, file = "../out/tyrosine_containing_background_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# also write the ones with no hit
tyrosines_containing_background_UNMATCHED <- tyrosines_containing_background[!tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]


write.table(tyrosines_containing_background_UNMATCHED, file = "../out/tyrosine_containing_background_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

```

```{r proteinID_DECOYbins}

# below code worked in saving the .csvs but returned empty list of data... 
# I'll just manually run in separate scripts for now
# # same logic as above applied to DECOY bins selected based on a roughkysimilar number of peptidoforms as the bin of interest 
# 
# for (i in 1:9) {
#   
#   print(names(DECOY_bins_list)[i])
#   print(nrow(DECOY_bins_list[[i]]))
# }
# 
# 
# DECOY_bins_list_in_SwissProt <- list ()
# 
# for (bin_name in names(DECOY_bins_list)) {
#     current_bin <- DECOY_bins_list[[bin_name]]
# 
#     # Split and clean protein IDs
#     id_list <- lapply(strsplit(current_bin$protein, ", "), function(x) unlist(strsplit(x, ", ")))
#     clean_id_list <- lapply(id_list, ProteinIDCleaningFunction)
#     unique_ids <- lapply(clean_id_list, unique)
# 
#     # Match to SwissProt and get cleaned IDs
#     cleaned_ids <- lapply(unique_ids, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
#     flattened_cleaned_ids <- sapply(cleaned_ids, function(x) paste(x, collapse = ","))
# 
#     # Add cleaned IDs to the bin DataFrame
#     current_bin$cleaned_protein_IDs <- flattened_cleaned_ids
# 
#     # Filter based on SwissProt entry
#     inSwissProt <- current_bin[current_bin$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry, ]
#     unmatched <- current_bin[!current_bin$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry, ]
# 
#     # Save the data
#     write.table(inSwissProt, file = paste0(project_dir,"out/DECOY", bin_name, "_inSwissProt.tsv"), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
#     write.table(unmatched, file = paste0(project_dir,"out/DECOY", bin_name, "_UNMATCHED.tsv"), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# }

```

```{r cluster_profiler_prepare_inputs_for_GOterms}
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
# library(BiocFileCache)
# library(dbplyr)
# need to downgrade devtools for biomart to work #stackoverflow
# devtools::install_version("dbplyr", version = "2.3.4")


## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# Get the corresponding Entrez IDs for all UniProt IDs that we can
Uniprot = getBM(
  attributes=c('ensembl_gene_id','uniprotswissprot'), 
  mart = ensembl)

# 84 of our background IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
# 0 of our foreground IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)



# convert swiss prot to ensembl gene ids and remove unmatched
background_genes <- extractEnsemblGeneIDs(tyrosines_containing_background_inSwissProt, Uniprot)

# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)

# do the same for each DECOY dataset
# 
# # Initialize a list to store the Ensembl gene IDs for each decoy dataset
# DECOY_genes_list <- list()
# 
# # Loop through each decoy dataset, extract Ensembl gene IDs, and store them in the list
# for (i in 1:length(DECOY_bins_list)) {
#   decoy_genes <- extractEnsemblGeneIDs(DECOY_bins_list[[i]], Uniprot)
#   DECOY_genes_list[[i]] <- decoy_genes
# }

```

```{r clusterprofiler_GOenrichment_bin of interest}
#### now we have the input for cluster profiler. lets run the GO term enrichment analysis as per the omics course, but change the palue cutoffs to e.g. 1 and then manually filter on p value not adjusted p val

cluster_GO_MF <- enrichGO(gene      = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 1,
                       qvalueCutoff = 0.3504)
# 


########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
max(GO_term_dataframe_MF$qvalue)
GO_term_dataframe_MF <- GO_term_dataframe_MF[GO_term_dataframe_MF$pvalue < 0.05,]
max(GO_term_dataframe_MF$qvalue)
# [1] 0.3503261 - retrospectively set to that


goplot(cluster_GO_MF)  
barplot(cluster_GO_MF)


cluster_GO_CC <- enrichGO(gene         = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 1,
                       qvalueCutoff = 0.42)

GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
max(GO_term_dataframe_CC$qvalue)
GO_term_dataframe_CC <- GO_term_dataframe_CC[GO_term_dataframe_CC$pvalue < 0.05,]
max(GO_term_dataframe_CC$qvalue) #[1] 0.4191858
goplot(cluster_GO_CC)  
barplot(cluster_GO_CC)

######### now for biological processes 
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 1,
                       qvalueCutoff = 0.324)

GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
max(GO_term_dataframe_BP$qvalue)
# here more stringent otherwise too many hits
GO_term_dataframe_BP <- GO_term_dataframe_BP[GO_term_dataframe_BP$pvalue < 0.005,]

max(GO_term_dataframe_BP$qvalue) # 0.4399577
goplot(cluster_GO_BP)  
barplot(cluster_GO_BP)


```

```{r treeplot_attempt}
library(GOSemSim)
library(enrichplot)

# NB: treeplot might not be a good choice as we have a small number of enriched terms!
# Use function 'godata' to create a GO similarity data object
# since BP had no significant hits lets only do it for MF; CC only had 3 GO terms
GO_similarity_MF <- godata('org.Hs.eg.db', ont="MF")
GO_similarity_CC <- godata('org.Hs.eg.db', ont="CC")
GO_similarity_BP <- godata('org.Hs.eg.db', ont="BP")
#to have treeplots work these edits need to be made to installation 
# install.packages("ggnewscale")
# devtools::install_version("tidytree", version = "0.4.2")



### to fix Error in offspring.tbl_tree_item(.data = .data, .node = .node, tiponly = tiponly,  : could not find function "offspring.tbl_tree_item" I copied this solution from: https://github.com/YuLab-SMU/enrichplot/issues/249
nodeid.tbl_tree <- utils::getFromNamespace("nodeid.tbl_tree", "tidytree")
rootnode.tbl_tree <- utils::getFromNamespace("rootnode.tbl_tree", "tidytree")
offspring.tbl_tree <- utils::getFromNamespace("offspring.tbl_tree", "tidytree")
offspring.tbl_tree_item <- utils::getFromNamespace(".offspring.tbl_tree_item", "tidytree")
child.tbl_tree <- utils::getFromNamespace("child.tbl_tree", "tidytree")
parent.tbl_tree <- utils::getFromNamespace("parent.tbl_tree", "tidytree")

# Add similarity matrix to the enrichment result
cluster_GO_tree_MF <- pairwise_termsim(cluster_GO_MF, method = "Wang", semData = GO_similarity_MF)
treeplot(cluster_GO_tree_MF)


cluster_GO_tree_CC <- pairwise_termsim(cluster_GO_CC, method = "Wang", semData = GO_similarity_CC)
treeplot(cluster_GO_tree_CC)

cluster_GO_tree_BP <- pairwise_termsim(cluster_GO_BP, method = "Wang", semData = GO_similarity_BP)
treeplot(cluster_GO_tree_BP)


```

```{r KEGG pathway enrichment}
# I might need entrez IDs, otherwise I get NULL
library(biomaRt)
library(ggplot2)
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

foreground_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                           filters = 'ensembl_gene_id',
                           values = foreground_genes,
                           mart = ensembl)

background_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                           filters = 'ensembl_gene_id',
                           values = background_genes,
                           mart = ensembl)

# make sure to convert to character too!
foreground_entrez_ids <- as.character(na.omit(foreground_entrez$entrezgene_id))
background_entrez_ids <- as.character(na.omit(background_entrez$entrezgene_id))
## this has cut down our background list to 4833 from 14633!
## foreground less affected and reduced from 492 to 412


kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 1, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
# dotplot(kegg_enrichment, showCategory = 10, font.size = 8)
# Error in ans[ypos] <- rep(yes, length.out = len)[ypos] : 
#   replacement has length zero
## we get no significant hits unless we adjust the cutoffs lets look at the results

dotplot(kegg_enrichment, showCategory = 10, font.size = 8) # returns only top 2
# effectively I want to get all with p value < 0.05 even if it's not corrected,
# but only 2 have q value of < 0.5 rest are fixed at ~ 0.95

# do dotplot manually
# extract df
KEGG_df <- kegg_enrichment@result

# filter down to just p<0.05
KEGG_Significant_Pathways <- KEGG_df[KEGG_df$pvalue <0.05,]
names(KEGG_Significant_Pathways)

# convert gene ratios to numbers

KEGG_Significant_Pathways$GeneRatio <- sapply(strsplit(KEGG_Significant_Pathways$GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))


ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
  geom_point(aes(size = Count, color = pvalue)) +
  scale_color_gradient(low = "red", high = "blue") +
  labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
  theme_bw() +
  theme(
    legend.position = "right",
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    plot.title = element_text(hjust = 0.5)
  ) +
  ggtitle("KEGG Pathways with p<0.05 but not p.adj")
ggsave("../out/KEGG_dotplot_bw_tyrosinesonly_binofint.png", plot = last_plot(), width = 6, height = 4, dpi = 300)

```

```{r Reactome_ORA}
library(ReactomePA)


reactome_ORA <- enrichPathway(gene=foreground_entrez_ids,
universe=background_entrez_ids,
pvalueCutoff = 1, readable=TRUE)
#no hits at pcutoff 0.05
head(reactome_ORA)
#even at cutoff 1 we get nothing. how is this possible? Could the genes in my
# fore and background just not be part of REACTOME?


```

```{r protein_ID_cleaning_by_bin}
#### DO NOT RUN THIS! THIS IS FOR THE WHOLE BIN NOT JUST PHOSPHOTYROSINE
# 
# foreground_proteins <- bin_of_interest$protein
# alt_foreground_proteins <- bin_of_interest$alt_protein
# 
# # run some checks
# # "A1L0S7" %in% SwissProt_Protein_IDs
# # "A1L0S7" %in% foreground_id_list
# 
# # Swiss_Prot_Human[Swiss_Prot_Human$Entry == "Q9Y2D9", ]
# 
# # 1) convert to list of lists to handle cases where peptidoform has multiple IDs
# # NB: this is only if we want to keep positional information, but I think we 
# # should be ok working with just one very long vector or list of all IDs within 
# # the bin as we're not running any significance tests prior to the 
# # cluster profiler analysis, but doing it this way just to be safe
# 
# foreground_id_list <- lapply(strsplit(foreground_proteins, ", "), function(x) unlist(strsplit(x, ", ")))
# 
# 
# clean_foreground_ID_list  <- lapply(foreground_id_list, function(IDs) {
#   
#   # step one, deal with NX_ etries
#   # Remove "NX_" prefix and any the suffix following a dash
#   cleaned_IDs <- gsub("^NX_|-.*", "", IDs)
#   
#   # step 2, deal with sp/ID/ cases
#   # Keep everything after "sp|" and before the second "|"
#   cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
#   
#   
#   # step 3 deal with gi|315259111|ref|NP_001186752.1| cases 
#   
#   cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
#   # looks for strings starting with gi and keeps 
#   # all text after the first occurance of NP_ up until but excluding the first subsequent |
#   
#   
#   # # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
#   # cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
#   # ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID. 
#   # after cleaning,keep only the unique IDs at this stage
#   cleaned_IDs <- unique(cleaned_IDs)
#   
#  return(cleaned_IDs)
# })
# 
# # convert to a list of all IDs to see which ones are in the SwissProt entries
# all_cleaned_IDs <- unique(unlist(clean_foreground_ID_list))
# 
# proteins_inSwissProt <- all_cleaned_IDs[all_cleaned_IDs%in% SwissProt_Protein_IDs]
# notinSwissProt <- all_cleaned_IDs[!all_cleaned_IDs%in% SwissProt_Protein_IDs]
# 
# notinSwissProt[1:20]
# 
# 
# # Split notinSwissProt into two groups: starting with NP_ (NCBI Reference Sequence) 
# # and others - likely uniprot IDs not part of SwissProt
# NCBI_RefSeqs <- notinSwissProt[grepl("^NP_", notinSwissProt)]
# notinSwissProt_others <- notinSwissProt[!grepl("^NP_", notinSwissProt)]
# 
# # Specify the file paths for each TSV file
# file_path_NCBI_RefSeqs <- "NCBI_RefSeqs.tsv"
# file_path_notinSwissProt_others <- "Unmatched_Others.tsv"
# 
# # Save NCBI_RefSeqs as a TSV file
# write.table(NCBI_RefSeqs, file = file_path_NCBI_RefSeqs, sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# # Save notinSwissProt_others as a TSV file
# write.table(notinSwissProt_others, file = file_path_notinSwissProt_others, sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# 
# # Use grep to find strings containing any of the specified special characters
# # these won't be uniprot IDs; rest are likely uniprot IDs
# 
# notUniProtIDs <- notinSwissProt_others[grep("_", notinSwissProt_others)]
# 
# UniProtIDs <- notinSwissProt_others[!(notinSwissProt_others %in% notUniProtIDs)]
# 
# 
# 
# write.table(notUniProtIDs, file = "remaining_exceptions.tsv", sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# 
# write.table(UniProtIDs, file = "UniProt_ButNotSwissProt_IDs_foreground.tsv", sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# # notinSwissProt_others_clean <- gsub("^CONTRIB_([^_]+)_.*", "\\1", notinSwissProt_others)
# 



```

```{r PHOSPHOTYROSINE_ONLY}
# what if we tried phosphotyrosines only for foreground and background:
phosphotyrosine_foreg <- foreground[grepl("Y2", foreground$peptidoform_id), ]
phosphotyrosine_backg <- background[grepl("Y2", background$peptidoform_id), ]

# this is 74 vs 1408 observations # hold on! 1408 is the same as we had before! 
# I have forgotten to correctly filter my background and have only selected
# phosphotyrosines,

# make sure no bias in inclusion criteria
# phosphotyrosine-containing peptidoforms - grab all associated protein IDs across all bins as a background? 
# vs foreground just the ones in the correct bin
# if indeed sulfo, we would get an enrichment in cytokines, secreted proteins, membrane proteins, or similar

# if random there should be no significant hits

# try also running for a different bin with a similar number of hits as the expected sulfo bin. 





# 5) bin matches to libraries of transmembrane and secreted proteins: 

# 5_1) how many of all peptides have IDs in any of these categories for all bins? 
# THIS is probably not very usefun info actually...

# 5_2) how many Tyrosine-containng are trans-memeb and how many are secreted (as proportion?) 

# 5_3) how many phospho-tryosine containing ones are secreted/transmemb? 

#### could our data suggest sulfation of other amino acids at all? 

```
