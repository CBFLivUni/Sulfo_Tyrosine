geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
# Close the PDF device
dev.off()
View(results)
cleaned_names
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_threshold_20_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Now, cleaned_names should have the format like 'mz_0.300-0.400'
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
# create a data frame with one row for each bin
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names
# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries
# for each bin, look at the corresponding data in post_GMM_data, and count:
# 1) the overall number of Tyrosine-containing peptides (one or more Y present in peptidoform ID coplumn)
# 2) the number of phosphotyrosine-containing peptides (Y243 present)
# 3) the total number of peptidoforms
# 4) calculate the proportion of tyrosine containing and proportion of phophotyrosine containing peptides in each bin
## NB: also do the same for Serine and Threonine to compare
# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df,
########## TYROSINE
tyrosine_containing_peptides_count = integer(length(postGMM_data)),
phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
tyrosine_containing_proportion = numeric(length(postGMM_data)),
phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
######### THREONINE
threonine_containing_peptides_count = integer(length(postGMM_data)),
phosphothreonine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
threonine_containing_proportion = numeric(length(postGMM_data)),
phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
######## SERINE
serine_containing_peptides_count = integer(length(postGMM_data)),
phosphoserine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
serine_containing_proportion = numeric(length(postGMM_data)),
phosphoserine_containing_proportion = numeric(length(postGMM_data)))
# test_df <- data.frame(peptidoform_id = c("TTT", "Y", "TYTY", "TY_Y243"))
# data <- test_df
# Iterate through each bin
for (i in seq_along(postGMM_data)) {
data <- postGMM_data[[i]]
results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
results$total_peptidoforms[i] <- nrow(data)
# Calculating proportions
results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
# Now for threonine
results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id))
# Calculating proportions
results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
## and for serine
results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id))
# Calculating proportions
results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
}
# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$pY_containing_fraction_of_Ycontaining <- results$phosphotyrosine_containing_peptides_count /
results$tyrosine_containing_peptides_count
# Ratio of phospho-Threonine to total Threonine-containing peptides
results$pT_containing_fraction_of_Tcontaining <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count
# Ratio of phospho-serine to total serine-containing peptides
results$pS_containing_fraction_of_Scontaining <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count
write.csv(results, file = "../out/PTM_proportions_results_by_bin_newdat.csv", row.names = FALSE)
## reorder column names
new_order <- c("bin_ID",
"lower_boundary",
"upper_boundary",
"total_peptidoforms",
"threonine_containing_peptides_count",
"serine_containing_peptides_count",
"tyrosine_containing_peptides_count",
"phosphothreonine_containing_peptides_count",
"phosphoserine_containing_peptides_count",
"phosphotyrosine_containing_peptides_count",
"threonine_containing_proportion",
"serine_containing_proportion",
"tyrosine_containing_proportion",
"phosphothreonine_containing_proportion",
"phosphoserine_containing_proportion",
"phosphotyrosine_containing_proportion",
"pT_containing_fraction_of_Tcontaining",
"pS_containing_fraction_of_Scontaining",
"pY_containing_fraction_of_Ycontaining"
)
results <- results[, new_order]
names(results)
# round the columns that contain proportions to 4 decimals for the plots - all except first 10
results[, 10:ncol(results)] <- lapply(results[, 10:ncol(results)], round, 4)
# check
head(results)
# also order by m/z
results <- results[order(results$lower_boundary), ]
# Then, plot with highlighting
# Create a new column 'highlight' based on conditions
results$highlight <- ifelse(results$bin_ID == "mz_-0.0125_-0.0075", "Bin of Interest",
ifelse(results$bin_ID %in% c("mz_0.0075_0.0125", "mz_0.0125_0.0175", "mz_0.0175_0.0225"), "DECOY", "Normal"))
# Assign color-blind friendly colors
color_blind_friendly_colors <- c("Bin of Interest" = "#E69F00", # orange
"DECOY" = "#56B4E9", # sky blue
"Normal" = "grey") # yellow
# Start PDF device
pdf("../out/BarPlots_byBin_20pc_individual.pdf", width = 11, height = 8.5)
# Loop through each column to create and save the plot
for (col in columns_to_plot) {
p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
geom_bar(stat = "identity", aes(fill = highlight)) +
scale_fill_manual(values = color_blind_friendly_colors) +
geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
# Close the PDF device
dev.off()
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
#separate the name into pars splitting at _
parts <- unlist(strsplit(name, "_"))
# Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
lower <- round(as.numeric(parts[2]), 4)
upper <- round(as.numeric(parts[3]), 4)
# Storing the boundaries
# index = 1
lower_boundaries[length(lower_boundaries) + 1] <<- lower
upper_boundaries[length(upper_boundaries) + 1] <<- upper
# Reconstructing the cleaned name (and returning it)
return(paste0("mz_", lower, "_", upper))
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
# specify the extension unique to your calibrated files
extension = "postGMM"
wd <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/"
# get all files of interest
bin_data_files <- list.files(wd, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_threshold_25_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Now, cleaned_names should have the format like 'mz_0.300-0.400'
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
# create a data frame with one row for each bin
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names
# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries
# for each bin, look at the corresponding data in post_GMM_data, and count:
# 1) the overall number of Tyrosine-containing peptides (one or more Y present in peptidoform ID coplumn)
# 2) the number of phosphotyrosine-containing peptides (Y243 present)
# 3) the total number of peptidoforms
# 4) calculate the proportion of tyrosine containing and proportion of phophotyrosine containing peptides in each bin
## NB: also do the same for Serine and Threonine to compare
# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df,
########## TYROSINE
tyrosine_containing_peptides_count = integer(length(postGMM_data)),
phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
tyrosine_containing_proportion = numeric(length(postGMM_data)),
phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
######### THREONINE
threonine_containing_peptides_count = integer(length(postGMM_data)),
phosphothreonine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
threonine_containing_proportion = numeric(length(postGMM_data)),
phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
######## SERINE
serine_containing_peptides_count = integer(length(postGMM_data)),
phosphoserine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
serine_containing_proportion = numeric(length(postGMM_data)),
phosphoserine_containing_proportion = numeric(length(postGMM_data)))
# test_df <- data.frame(peptidoform_id = c("TTT", "Y", "TYTY", "TY_Y243"))
# data <- test_df
# Iterate through each bin
for (i in seq_along(postGMM_data)) {
data <- postGMM_data[[i]]
results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
results$total_peptidoforms[i] <- nrow(data)
# Calculating proportions
results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
# Now for threonine
results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id))
# Calculating proportions
results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
## and for serine
results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id))
# Calculating proportions
results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
}
# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$pY_containing_fraction_of_Ycontaining <- results$phosphotyrosine_containing_peptides_count /
results$tyrosine_containing_peptides_count
# Ratio of phospho-Threonine to total Threonine-containing peptides
results$pT_containing_fraction_of_Tcontaining <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count
# Ratio of phospho-serine to total serine-containing peptides
results$pS_containing_fraction_of_Scontaining <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count
write.csv(results, file = "../out/PTM_proportions_results_by_bin_newdat.csv", row.names = FALSE)
## reorder column names
new_order <- c("bin_ID",
"lower_boundary",
"upper_boundary",
"total_peptidoforms",
"threonine_containing_peptides_count",
"serine_containing_peptides_count",
"tyrosine_containing_peptides_count",
"phosphothreonine_containing_peptides_count",
"phosphoserine_containing_peptides_count",
"phosphotyrosine_containing_peptides_count",
"threonine_containing_proportion",
"serine_containing_proportion",
"tyrosine_containing_proportion",
"phosphothreonine_containing_proportion",
"phosphoserine_containing_proportion",
"phosphotyrosine_containing_proportion",
"pT_containing_fraction_of_Tcontaining",
"pS_containing_fraction_of_Scontaining",
"pY_containing_fraction_of_Ycontaining"
)
results <- results[, new_order]
names(results)
# round the columns that contain proportions to 4 decimals for the plots - all except first 10
results[, 10:ncol(results)] <- lapply(results[, 10:ncol(results)], round, 4)
# check
head(results)
# also order by m/z
results <- results[order(results$lower_boundary), ]
# Then, plot with highlighting
# Create a new column 'highlight' based on conditions
results$highlight <- ifelse(results$bin_ID == "mz_-0.0125_-0.0075", "Bin of Interest",
ifelse(results$bin_ID %in% c("mz_0.0075_0.0125", "mz_0.0125_0.0175", "mz_0.0175_0.0225"), "DECOY", "Normal"))
# Assign color-blind friendly colors
color_blind_friendly_colors <- c("Bin of Interest" = "#E69F00", # orange
"DECOY" = "#56B4E9", # sky blue
"Normal" = "grey") # yellow
# Start PDF device
pdf("../out/BarPlots_byBin_25pc_individual.pdf", width = 11, height = 8.5)
# Loop through each column to create and save the plot
for (col in columns_to_plot) {
p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
geom_bar(stat = "identity", aes(fill = highlight)) +
scale_fill_manual(values = color_blind_friendly_colors) +
geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
columns_to_plot <- names(results)[4:(ncol(results)-1)]
# Start PDF device
pdf("../out/BarPlots_byBin_25pc_individual.pdf", width = 11, height = 8.5)
# Loop through each column to create and save the plot
for (col in columns_to_plot) {
p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
geom_bar(stat = "identity", aes(fill = highlight)) +
scale_fill_manual(values = color_blind_friendly_colors) +
geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
# Close the PDF device
dev.off()
# Close the PDF device
dev.off()
columns_to_plot
# Start PDF device
pdf("../out/BarPlots_byBin_25pc_individual.pdf", width = 11, height = 8.5)
# Loop through each column to create and save the plot
for (col in columns_to_plot) {
p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
geom_bar(stat = "identity", aes(fill = highlight)) +
scale_fill_manual(values = color_blind_friendly_colors) +
geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
# Close the PDF device
dev.off()
# specify the extension unique to your calibrated files
extension = "postGMM"
wd <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/"
# get all files of interest
bin_data_files <- list.files(wd, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_threshold_30_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Now, cleaned_names should have the format like 'mz_0.300-0.400'
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
# create a data frame with one row for each bin
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names
# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries
# for each bin, look at the corresponding data in post_GMM_data, and count:
# 1) the overall number of Tyrosine-containing peptides (one or more Y present in peptidoform ID coplumn)
# 2) the number of phosphotyrosine-containing peptides (Y243 present)
# 3) the total number of peptidoforms
# 4) calculate the proportion of tyrosine containing and proportion of phophotyrosine containing peptides in each bin
## NB: also do the same for Serine and Threonine to compare
# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df,
########## TYROSINE
tyrosine_containing_peptides_count = integer(length(postGMM_data)),
phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
tyrosine_containing_proportion = numeric(length(postGMM_data)),
phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
######### THREONINE
threonine_containing_peptides_count = integer(length(postGMM_data)),
phosphothreonine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
threonine_containing_proportion = numeric(length(postGMM_data)),
phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
######## SERINE
serine_containing_peptides_count = integer(length(postGMM_data)),
phosphoserine_containing_peptides_count = integer(length(postGMM_data)),
#total_peptidoforms = integer(length(postGMM_data)),
serine_containing_proportion = numeric(length(postGMM_data)),
phosphoserine_containing_proportion = numeric(length(postGMM_data)))
# test_df <- data.frame(peptidoform_id = c("TTT", "Y", "TYTY", "TY_Y243"))
# data <- test_df
# Iterate through each bin
for (i in seq_along(postGMM_data)) {
data <- postGMM_data[[i]]
results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
results$total_peptidoforms[i] <- nrow(data)
# Calculating proportions
results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
# Now for threonine
results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id))
# Calculating proportions
results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
## and for serine
results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id))
# Calculating proportions
results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
}
# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$pY_containing_fraction_of_Ycontaining <- results$phosphotyrosine_containing_peptides_count /
results$tyrosine_containing_peptides_count
# Ratio of phospho-Threonine to total Threonine-containing peptides
results$pT_containing_fraction_of_Tcontaining <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count
# Ratio of phospho-serine to total serine-containing peptides
results$pS_containing_fraction_of_Scontaining <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count
write.csv(results, file = "../out/PTM_proportions_results_by_bin_newdat.csv", row.names = FALSE)
## reorder column names
new_order <- c("bin_ID",
"lower_boundary",
"upper_boundary",
"total_peptidoforms",
"threonine_containing_peptides_count",
"serine_containing_peptides_count",
"tyrosine_containing_peptides_count",
"phosphothreonine_containing_peptides_count",
"phosphoserine_containing_peptides_count",
"phosphotyrosine_containing_peptides_count",
"threonine_containing_proportion",
"serine_containing_proportion",
"tyrosine_containing_proportion",
"phosphothreonine_containing_proportion",
"phosphoserine_containing_proportion",
"phosphotyrosine_containing_proportion",
"pT_containing_fraction_of_Tcontaining",
"pS_containing_fraction_of_Scontaining",
"pY_containing_fraction_of_Ycontaining"
)
results <- results[, new_order]
names(results)
# round the columns that contain proportions to 4 decimals for the plots - all except first 10
results[, 10:ncol(results)] <- lapply(results[, 10:ncol(results)], round, 4)
# check
head(results)
# also order by m/z
results <- results[order(results$lower_boundary), ]
# Then, plot with highlighting
# Create a new column 'highlight' based on conditions
results$highlight <- ifelse(results$bin_ID == "mz_-0.0125_-0.0075", "Bin of Interest",
ifelse(results$bin_ID %in% c("mz_0.0075_0.0125", "mz_0.0125_0.0175", "mz_0.0175_0.0225"), "DECOY", "Normal"))
# Assign color-blind friendly colors
color_blind_friendly_colors <- c("Bin of Interest" = "#E69F00", # orange
"DECOY" = "#56B4E9", # sky blue
"Normal" = "grey") # yellow
# Start PDF device
pdf("../out/BarPlots_byBin_30pc_individual.pdf", width = 11, height = 8.5)
# Loop through each column to create and save the plot
for (col in columns_to_plot) {
p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
geom_bar(stat = "identity", aes(fill = highlight)) +
scale_fill_manual(values = color_blind_friendly_colors) +
geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
scale_color_manual(values = color_blind_friendly_colors) +
theme_minimal() +
labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
guides(fill = guide_legend(title = "Category"), color = FALSE)
print(p) # Print the plot to the PDF device
}
# Close the PDF device
dev.off()
getwd()
setwd("C:/Users/jtzve/Desktop/Sufo_Tyrosine/Figures_draft/scripts/")
pages_15pc_individual <- c(43, 106, 122, 29)
pdf_convert("../in/histograms_post_auc_filtering_15pc_individualAUCbin_-0.0125_-0.0075.pdf",
format = "png",
pages = pages_15pc_individual,
filenames = NULL,
dpi = 600, opw = "", upw = "", verbose = TRUE)
