---
title: "Motif Enrichment Analysis"
format: html
editor: visual
---



```{r libraries}
library(tidyverse)
library(stringr) 
require(rmotifx)
require(ggplot2)
require(ggseqlogo)
library(Biostrings)
library(stringr)
library(tidyverse)
require(gridExtra)
library(grid)
library(miscset)


```

```{r directories}
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/04_MotifEnrichment/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/04_MotifEnrichment/data/"

# specify the folder and get all FASTA files to make up our protein sequence library
fasta_path <- paste0(data_dir, "SwissProt_FASTA_files/") 
fasta_files <- list.files(fasta_path, pattern = "\\.fasta$", full.names = TRUE)

```

```{r functions}
## function to extract up to 7 peptides down and upstreeam of peptide sequence 
# from its corresponding FASTA file

extract_surrounding_seq <- function(full_seq, peptide_seq) {
  match_positions <- gregexpr(peptide_seq, full_seq, fixed = TRUE)[[1]]
  
  if (match_positions[1] == -1) {
    return("not matched") # Return "not matched" if the peptide sequence is not found
  } else {
    # Handle multiple matches
    surrounding_seqs <- sapply(match_positions, function(pos) {
      start <- max(1, pos - 7)
      end <- min(nchar(full_seq), pos + nchar(peptide_seq) - 1 + 7)
      substr(full_seq, start, end)
    })
    
    # Combine multiple matches into a single string (if needed)
    return(paste(surrounding_seqs, collapse = "; "))
  }
}


## same function as above but modified to only extract up to 7 peptides up and down of the first and last Y amino acide in the peptide
extract_tyr_surrounding_seq <- function(full_seq, peptide_seq) {
  first_Y_pos <- regexpr("Y", peptide_seq)[[1]] # Position of first Y in peptide
  last_Y_pos <- regexpr("Y", str_rev(peptide_seq), fixed = TRUE)[[1]] # Position of last Y in reversed peptide
  last_Y_pos <- nchar(peptide_seq) - last_Y_pos + 1 # Correct position in original peptide
  
  if (first_Y_pos == -1 || last_Y_pos == -1) {
    return("no Y in peptide") # If no Y found in peptide, return this message
  } else {
    full_seq_start_pos <- gregexpr(peptide_seq, full_seq, fixed = TRUE)[[1]][1] # Start of peptide in full sequence
    # Adjusting start and end positions to include surrounding amino acids, considering sequence boundaries
    start_pos <- max(1, full_seq_start_pos + first_Y_pos - 8)
    end_pos <- min(nchar(full_seq), full_seq_start_pos + last_Y_pos + 6)
    
    return(substr(full_seq, start_pos, end_pos))
  }
}


#### same function but dealing with multiple instances of tyrosine
extract_surrounding_seqs_for_each_Y <- function(full_seq, peptide_seq) {
    Y_positions <- gregexpr("Y", peptide_seq, fixed = TRUE)[[1]]
    
    if (Y_positions[1] == -1) {
        return("no Y in peptide") # Return this if no Y is found in the peptide
    } else {
        surrounding_seqs <- sapply(Y_positions, function(pos) {
            full_seq_pos <- gregexpr(peptide_seq, full_seq, fixed = TRUE)[[1]][1] + pos - 1
            start_pos <- max(1, full_seq_pos - 7)
            end_pos <- min(nchar(full_seq), full_seq_pos + 7)
            substr(full_seq, start_pos, end_pos)
        }, USE.NAMES = FALSE)
        
        # Combine multiple sequences into a single string, separated by ";"
        return(paste(surrounding_seqs, collapse = "; "))
    }
}




##### Kerry's function for making the plots:
perform_motif_analysis <- function(fg.seqs, bg.seqs) {
    mot <- motifx(fg.seqs, bg.seqs, central.res = 'ST', min.seqs = 20, pval.cutoff = 1e-6)
    
    plots <- list()
    pos <- c("-7","-6","-5","-4","-3","-2","-1","p","1","2","3","4","5","6","7")
    break_list <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
    
    for (val in mot$motif) {
        m <- grep(val, fg.seqs, value = TRUE)
        motif_plot <- ggplot() + geom_logo(m, method="probability") +
                      scale_x_continuous(labels=pos, breaks=break_list) +
                      ggtitle(val) +
                      theme(legend.position = "none")
        plots[[length(plots) + 1]] <- motif_plot
    }
    
    return(plots)
}

```

```{r readindata}
# read in the FASTA sequences as a libray of protein sequences
# use readAAStringSet friom BioStrings, not the function for nucleotides!
protein_sequences <- lapply(fasta_files, function(file) {
  readAAStringSet(file)
})

# flatten to vector to make working with it easier
protein_sequences_vector <- unlist(lapply(protein_sequences, as.character))
#inspect names - need some cleaning
head(names(protein_sequences_vector))
# need to extract SwissProt IDs and reassign as names (everything after sp| and bevore the next |)
names(protein_sequences_vector) <- sub("sp\\|([^|]+)\\|.*", "\\1", names(protein_sequences_vector))

## read in the background, foregorund, and DECOYforeground data for the enrichment analysis.
background <- read.csv("../data/tyrosine_containing_background_inSwissProt.tsv",
                       sep = "\t")

foreground <- read.csv("../data/tyrosine_containing_foreground_inSwissProt.tsv",
                       sep = "\t")

DECOYforeground <- read.csv("../data/tyrosine_containing_foreground_DECOYBIN_inSwissProt.tsv",
                       sep = "\t")

```


```{r background_dataframe_generation}
# sanity check - are all peptidoforms unique? 
length(unique(background$peptidoform_id))
# yes
names(background)
# subset data to only include columns useful for motif enrichment
background <- background[,c("peptidoform_id","cleaned_protein_IDs")]

# retrieve peptide sequence for each peptidoform - remove _ and all that follows it
background$peptide <- sub("_.*", "", background$peptidoform_id)
#sanity check:  double-check all peptide IDs are in the sequences we have extracted
sum(background$cleaned_protein_IDs %in% names(protein_sequences_vector))
#14718 so yes


# retrieve the sequences surrounding the peptide sequence from the protein sequence
background$pep_surrounding_seq <- NA

for (i in 1:nrow(background)) {
  peptide_id <- background$cleaned_protein_IDs[i]
  peptide_seq <- background$peptide[i]

  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    background$pep_surrounding_seq[i] <- extract_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    background$surrounding_seq[i] <- "not matched"
  }
}


## do the same but just for the sequences surrounding a tyrosine
background$tyr_surrounding_seq <- NA

for (i in 1:nrow(background)) {
  peptide_id <- background$cleaned_protein_IDs[i]
  peptide_seq <- background$peptide[i]
  
  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    background$tyr_surrounding_seq[i] <- extract_tyr_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    background$surrounding_seq[i] <- "not matched"
  }
}

### TODO we need to deal with cases where more than one tyrosine present and split into multiple sequences 

## do the same but just for the sequences surrounding a tyrosine
background$surrounding_seq_Y_centered <- NA

for (i in 1:nrow(background)) {
    peptide_id <- background$cleaned_protein_IDs[i]
    peptide_seq <- background$peptide[i]
    
    if (peptide_id %in% names(protein_sequences_vector)) {
        full_seq <- protein_sequences_vector[peptide_id]
        background$surrounding_seq_Y_centered[i] <- extract_surrounding_seqs_for_each_Y(full_seq, peptide_seq)
    } else {
        warning(paste("Peptide ID", peptide_id, "not found in sequences."))
        background$surrounding_seq_Y_centered[i] <- "not matched"
    }
}



# get all unique background motifs
temp_unique_background_motifs <- unique(background$surrounding_seq_Y_centered)
temp_unique_background_motifs[1:10]

# split cases where multiple motifs separated by ;
split_background_motifs <- strsplit(temp_unique_background_motifs, ";\\s*")
# flattent to a vector
all_background_motifs <- unlist(split_background_motifs)
# get unique ones 
unique_background_motifs <- unique(all_background_motifs)

# exclude motifs where y is too close to start or end of protein sequence
final_background_motifs_to_use <- unique_background_motifs[nchar(unique_background_motifs) == 15]

length(final_background_motifs_to_use)
# 4978 total

rm("split_background_motifs", "all_background_motifs", "temp_unique_background_motifs")

```


```{r foreground_df_generation}

# sanity check - are all peptidoforms unique? 
length(unique(foreground$peptidoform_id))
# yes
names(foreground)
# subset data to only include columns useful for motif enrichment
foreground <- foreground[,c("peptidoform_id","cleaned_protein_IDs")]

# retrieve peptide sequence for each peptidoform - remove _ and all that follows it
foreground$peptide <- sub("_.*", "", foreground$peptidoform_id)
#sanity check:  double-check all peptide IDs are in the sequences we have extracted
sum(foreground$cleaned_protein_IDs %in% names(protein_sequences_vector))
#492 so yes


# retrieve the sequences surrounding the peptide sequence from the protein sequence
foreground$pep_surrounding_seq <- NA

for (i in 1:nrow(foreground)) {
  peptide_id <- foreground$cleaned_protein_IDs[i]
  peptide_seq <- foreground$peptide[i]

  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    foreground$pep_surrounding_seq[i] <- extract_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    foreground$surrounding_seq[i] <- "not matched"
  }
}


## do the same but just for the sequences surrounding a tyrosine
foreground$tyr_surrounding_seq <- NA

for (i in 1:nrow(foreground)) {
  peptide_id <- foreground$cleaned_protein_IDs[i]
  peptide_seq <- foreground$peptide[i]
  
  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    foreground$tyr_surrounding_seq[i] <- extract_tyr_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    foreground$surrounding_seq[i] <- "not matched"
  }
}

### TODO we need to deal with cases where more than one tyrosine present and split into multiple sequences 


## do the same but just for the sequences surrounding a tyrosine
foreground$surrounding_seq_Y_centered <- NA

for (i in 1:nrow(foreground)) {
    peptide_id <- foreground$cleaned_protein_IDs[i]
    peptide_seq <- foreground$peptide[i]
    
    if (peptide_id %in% names(protein_sequences_vector)) {
        full_seq <- protein_sequences_vector[peptide_id]
        foreground$surrounding_seq_Y_centered[i] <- extract_surrounding_seqs_for_each_Y(full_seq, peptide_seq)
    } else {
        warning(paste("Peptide ID", peptide_id, "not found in sequences."))
        foreground$surrounding_seq_Y_centered[i] <- "not matched"
    }
}



# get all unique foreground motifs
temp_unique_foreground_motifs <- unique(foreground$surrounding_seq_Y_centered)
temp_unique_foreground_motifs[1:10]

# split cases where multiple motifs separated by ;
split_foreground_motifs <- strsplit(temp_unique_foreground_motifs, ";\\s*")
# flattent to a vector
all_foreground_motifs <- unlist(split_foreground_motifs)
# get unique ones 
unique_foreground_motifs <- unique(all_foreground_motifs)

# exclude motifs where y is too close to start or end of protein sequence
final_foreground_motifs_to_use <- unique_foreground_motifs[nchar(unique_foreground_motifs) == 15]

discarded_foreground_motifs <- unique_foreground_motifs[nchar(unique_foreground_motifs) != 15]

length(final_foreground_motifs_to_use)
# 558 total
test <- background[background$pep_surrounding_seq == "not matched",]
rm("split_foreground_motifs", "all_foreground_motifs", "temp_unique_foreground_motifs")

```


```{r DECOYforeground_df_generation}

# sanity check - are all peptidoforms unique? 
length(unique(DECOYforeground$peptidoform_id))
# yes
names(DECOYforeground)
# subset data to only include columns useful for motif enrichment
DECOYforeground <- DECOYforeground[,c("peptidoform_id","cleaned_protein_IDs")]

# retrieve peptide sequence for each peptidoform - remove _ and all that follows it
DECOYforeground$peptide <- sub("_.*", "", DECOYforeground$peptidoform_id)
#sanity check:  double-check all peptide IDs are in the sequences we have extracted
sum(DECOYforeground$cleaned_protein_IDs %in% names(protein_sequences_vector))
#657 so yes


# retrieve the sequences surrounding the peptide sequence from the protein sequence
DECOYforeground$pep_surrounding_seq <- NA

for (i in 1:nrow(DECOYforeground)) {
  peptide_id <- DECOYforeground$cleaned_protein_IDs[i]
  peptide_seq <- DECOYforeground$peptide[i]

  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    DECOYforeground$pep_surrounding_seq[i] <- extract_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    DECOYforeground$surrounding_seq[i] <- "not matched"
  }
}


## do the same but just for the sequences surrounding a tyrosine
DECOYforeground$tyr_surrounding_seq <- NA

for (i in 1:nrow(DECOYforeground)) {
  peptide_id <- DECOYforeground$cleaned_protein_IDs[i]
  peptide_seq <- DECOYforeground$peptide[i]
  
  if (peptide_id %in% names(protein_sequences_vector)) {
    full_seq <- protein_sequences_vector[peptide_id]
    DECOYforeground$tyr_surrounding_seq[i] <- extract_tyr_surrounding_seq(full_seq, peptide_seq)
  } else {
    warning(paste("Peptide ID", peptide_id, "not found in sequences."))
    DECOYforeground$surrounding_seq[i] <- "not matched"
  }
}

### TODO we need to deal with cases where more than one tyrosine present and split into multiple sequences 

## do the same but just for the sequences surrounding a tyrosine
DECOYforeground$surrounding_seq_Y_centered <- NA

for (i in 1:nrow(DECOYforeground)) {
    peptide_id <- DECOYforeground$cleaned_protein_IDs[i]
    peptide_seq <- DECOYforeground$peptide[i]
    
    if (peptide_id %in% names(protein_sequences_vector)) {
        full_seq <- protein_sequences_vector[peptide_id]
        DECOYforeground$surrounding_seq_Y_centered[i] <- extract_surrounding_seqs_for_each_Y(full_seq, peptide_seq)
    } else {
        warning(paste("Peptide ID", peptide_id, "not found in sequences."))
        DECOYforeground$surrounding_seq_Y_centered[i] <- "not matched"
    }
}



# get all unique DECOYforeground motifs
temp_unique_DECOYforeground_motifs <- unique(DECOYforeground$surrounding_seq_Y_centered)
temp_unique_DECOYforeground_motifs[1:10]

# split cases where multiple motifs separated by ;
split_DECOYforeground_motifs <- strsplit(temp_unique_DECOYforeground_motifs, ";\\s*")
# flattent to a vector
all_DECOYforeground_motifs <- unlist(split_DECOYforeground_motifs)
# get unique ones 
unique_DECOYforeground_motifs <- unique(all_DECOYforeground_motifs)

length(unique_DECOYforeground_motifs)
# 730 total

rm("split_DECOYforeground_motifs", "all_DECOYforeground_motifs", "temp_unique_DECOYforeground_motifs")


```



```{r motifenrichmentanalyses}
# For unique_foreground_motifs

## got error, some motifs might be shorter than 15 amino acid sequences if Y too close to start or end of protein, discard these rare cases.
unique_foreground_motifs_15aalong <- unique_foreground_motifs[]
nchar(unique_foreground_motifs)


fg_plots <- perform_motif_analysis(unique_foreground_motifs, unique_background_motifs)

# For unique_DECOYforeground_motifs
decoy_fg_plots <- perform_motif_analysis(unique_DECOYforeground_motifs, unique_background_motifs)


# Display or save plots for foreground motifs
grid.arrange(grobs=fg_plots)

# Display or save plots for DECOY foreground motifs
grid.arrange(grobs=decoy_fg_plots)


```


