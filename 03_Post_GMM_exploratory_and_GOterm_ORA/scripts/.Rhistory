filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_4"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_5"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_6"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_7"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_8"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
head(filtered_data[[i]])
i = 19
head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
# specify the extension unique to your calibrated files
extension = "thresholded_calibrated.tsv"
batch = "batch2_9"
# get all calibrated files
calibrated_files <- list.files(paste0(wd, batch), pattern = extension, full.names = TRUE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# input_filenames <- input_filenames[16]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
print("reading in data")
for (i in 1:length(calibrated_files)) {
print(calibrated_files[[i]])
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
print(i/length(input_filenames)*100)
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
# source the PTM filtering function
source("scripts/PTM_filtering_fun.R")
# determine what PTMs are of interest to use in function
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
print(i)
print(i/length(calibrated_data)*100)
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
PTMs_of_interest = PTMs_of_interest)
}
# once again set the name for each dataset
names(filtered_data) <- stripped_filenames
# then remove the list of read in data to free memory
rm(calibrated_data)
gc()
source("scripts/Generate_peptidoform_ID_v2.R")
# add peptidoform ID and its scipher + dataset ID to each dataset to enable subsequent filtering
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
# i = 19
for (i in 1:length(filtered_data)) {
dataset_ID <- names(filtered_data[i])
print(dataset_ID)
print(i/length(filtered_data)*100)
filtered_data[[i]]$dataset_ID <- dataset_ID  # set the dataset ID to its unique folder name
peptidoform_id_summaries[[i]] <- Generate_Peptidoform_ID(df = filtered_data[[i]],
outname = dataset_ID) # set name for saving .csv files
}
# head(filtered_data[[i]])
# the data has been written... did not return df for some reason, maybe I didn't source the function after changing? anyway...
rm(peptidoform_id_summaries)
rm(filtered_data)
gc()
library(stringr)
wd <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/01_Sulfotyrosine_Data_Processing/scripts"
setwd(wd)
# read in the aggregated data
test <- read.csv("../out/new_peptidoform_IDs_aggregated_by_peptidoform_ID.csv", nrows = 10000)
names(test)
test1[9,]
test1<-test[1:50,]
test1[9,]
# for columns that are not the peptidoform ID one
for (i in 1:ncol(test1)){
# Apply a cleaning function to:
cleaned_col <- lapply(test1[,i], function(x) {
# 1) # Remove brackets and single quotes from the string
clean_string <- gsub("\\[|\\]|'", "", x)
# 2) replace ; with , for the alt protein column (number 5)
clean_string <- gsub(";", ",", clean_string)
# 3) # Split into elements at every comma removing any white space to follow it
elements <- unlist(strsplit(clean_string, ',\\s*'))
# 4) return all elements
return(elements)
})
# 5) Convert the list of vectors into a single character string per row
# by collapsing the elements
# for the calibrated mass errors column (number 2), retain all elements.
if (i==2){
test1[,i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
} else {
# for all other columnsm reatin only the unique values
test1[,i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
}
}
View(test1)
names(test)
test1<-test[1:50,]
names(test)
test1<-test[1:50,]
cleaned_col <- lapply(test1[,1], function(x) {
# 1) # Remove brackets and single quotes from the string
clean_string <- gsub("\\[|\\]|'", "", x)
}
}
cleaned_col <- lapply(test1[,1], function(x) {
# 1) # Remove brackets and single quotes from the string
clean_string <- gsub("\\[|\\]|'", "", x)
})
cleaned_col <- lapply(test1[,1], function(x) {
# 1) # Remove brackets and single quotes from the string
clean_string <- gsub("\\[|\\]|'", "", x)
elements <- unlist(strsplit(clean_string, ',\\s*'))
# 4) return all elements
return(elements)
})
View(cleaned_col)
# 1) # Remove brackets and single quotes from the string
clean_string <- gsub("\\[|\\]|'", "", test1[,1])
elements <- unlist(strsplit(clean_string, ',\\s*'))
cleaned_IDs <- gsub("\\[|\\]|'", "", test2[,1])
test2 <- test
cleaned_IDs <- gsub("\\[|\\]|'", "", test2[,1])
test2[,1] <- cleaned_IDs
View(test2)
# read in the aggregated data
test <- read.csv("../out/new_peptidoform_IDs_aggregated_by_peptidoform_ID.csv")
cleaned_IDs <- gsub("\\[|\\]|'", "", test[,1])
test[,1] <- cleaned_IDs
names(test)
write.csv("../out/clean_new_peptidoform_IDs_aggregated_by_peptidoform_ID.csv", row.names = FALSE)
write.csv(test, "../out/clean_new_peptidoform_IDs_aggregated_by_peptidoform_ID.csv", row.names = FALSE)
test2 <- read.csv("../out/clean_new_peptidoform_IDs_aggregated_by_peptidoform_ID.csv")
test == test2
# specify the extension unique to your calibrated files
extension = "postGMM"
wd <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/"
# get all files of interest
bin_data_files <- list.files(wd, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
library(tidyverse)
library(stringr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
library(ggplot2)
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/"
source("GO_Enrichment_ORA_helper_functions.R")
setwd(paste0(project_dir, "/scripts"))
source("GO_Enrichment_ORA_helper_functions.R")
########### read in data ###########
# specify the extension unique to your calibrated files
extension = "postGMM"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
############## remove pythonic remnants from data ##############
# we need to clean the read in data as it contains python chaacters (e.g. [] for a list)
# rm(cleaned_postGMM_data, test)
gc()
cleaned_postGMM_data <- list()
for (i in 1:length(postGMM_data)) {
cleaned_postGMM_data[[i]] <- clean_data(postGMM_data[[i]])
print(i/length(postGMM_data))
}
