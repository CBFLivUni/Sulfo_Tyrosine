---
title: "Post_GMM_Analysis"
format: pdf
editor: visual
---

```{r libraries}
library(tidyverse)
library(stringr) 
library(ggplot2)

```

```{r directories}
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/06_histograms_of_peptidoforms_of_interest_per_dataset/"

# we want to use the peptidoform ID aggregated data from individual experiments

data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/01_Sulfotyrosine_Data_Processing/out/new_peptidoform_IDs/"
gc()
```

```{r functions}
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
  
  #separate the name into pars splitting at _
  parts <- unlist(strsplit(name, "_"))
 
  # Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
  lower <- round(as.numeric(parts[2]), 4)
  upper <- round(as.numeric(parts[3]), 4)

  # Storing the boundaries
  # index = 1
  lower_boundaries[length(lower_boundaries) + 1] <<- lower
  upper_boundaries[length(upper_boundaries) + 1] <<- upper

  # Reconstructing the cleaned name (and returning it)
  return(paste0("mz_", lower, "_", upper))
}


clean_data <- function(data) {
  for (i in 1:ncol(data)) {
    cleaned_col <- lapply(data[, i], function(x) {
      clean_string <- gsub("\\[|\\]|'", "", x)
      if (i == 5) {
        clean_string <- gsub(";", ",", clean_string)
      }
      elements <- unlist(strsplit(clean_string, ',\\s*'))
      return(elements)
    })

    if (i == 2) {
      data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
    } else {
      data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
    }
  }
  return(data)
}

# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
  
  # step one, deal with NX_ etries
  # Remove "NX_" prefix and any the suffix following a dash
  cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)


  
  # step 2, deal with sp/ID/ cases
  # Keep everything after "sp|" and before the second "|"
  cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
  
  
  # step 3 deal with gi|315259111|ref|NP_001186752.1| cases 
  
  cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
  # looks for strings starting with gi and keeps 
  # all text after the first occurance of NP_ up until but excluding the first subsequent |
  
  
  # # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
  # cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
  # ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID?
  # after cleaning,keep only the unique IDs at this stage
  cleaned_IDs <- unique(cleaned_IDs)
  
 return(cleaned_IDs)
}

## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
  # First, try splitting with "; "
  split_result <- strsplit(string, "; ")
  # If the length of any split_result is 1, it means there was no "; " to split on
  # In this case, try splitting with just ";"
  if (any(sapply(split_result, length) == 1)) {
    split_result <- strsplit(string, ";")
  }
  return(split_result)
}

## to process a sublist of a list of lists where each sublist is a row cell of 
# the protein IDs.

# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is


process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
  # Check for hits in Swiss_Prot_Human$Entry
  entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
  if (length(entry_hits) > 0) {
    return(entry_hits)
  }


  # Check for hits in Swiss_Prot_Human$neXtProt
  for (id in sublist) {
    if (any(sapply(neXtProt_list, function(x) id %in% x))) {
      matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
      return(Swiss_Prot_Human$Entry[matching_row])
    }
  }

  # Check for hits in Swiss_Prot_Human$RefSeq
  for (id in sublist) {
    if (any(sapply(RefSeq_list, function(x) id %in% x))) {
      matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
      return(Swiss_Prot_Human$Entry[matching_row])
    }
  }

  # If no matches, return the original sublist
  return(sublist)
}


#### subsetting swiss prot gene ids amnd returning uniprot ones for enrichment
extractEnsemblGeneIDs <- function(dataSet, uniprotMapping) {
  # subset to only include IDs present in UniProt mapping
  subsetData <- dataSet[dataSet$cleaned_protein_IDs %in% uniprotMapping$uniprotswissprot,]

  # match SwissProt IDs in the UniProt data frame to get the position index
  matchedIndices <- match(subsetData$cleaned_protein_IDs, uniprotMapping$uniprotswissprot)

  # rxtract corresponding ENSEMBL Gene IDs
  ensemblGeneIDs <- uniprotMapping$ensembl_gene_id[matchedIndices]

  # remove NAs if any (in case some SwissProt IDs didn't have a match)
  ensemblGeneIDs <- na.omit(ensemblGeneIDs)

  return(ensemblGeneIDs)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
# 
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
# 
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
# 
# # Remove the objects
# rm(list = objects_to_remove)
# 
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
# 
# rm("all_objects", "data_objects")


```

## Get proportion of tyrosine-containing peptides

For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)

```{r clean_file_names, echo=FALSE}
# specify the extension unique to your calibrated files
extension = "_peptidoforms.csv"

# get all files of interest in absolut path
data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)

# and get file names
input_filenames <- basename(data_files)

clean_names <- gsub(extension, "", input_filenames)

peptidoforms_potentially_sulfated <- read.csv(paste0(project_dir, "in/potential_sulfo_peptidoforms_.csv"))
store <- peptidoforms_potentially_sulfated

# let's get a test subset of just 2 rows with few datasets to run the code on - rows 5 and 21
peptidoforms_potentially_sulfated <- store[c(5,21),]


```

```{r read_in_andplotting_for_each_peptidoform}

# Loop through each row in peptidoforms_potentially_sulfated
for (i in 1:nrow(peptidoforms_potentially_sulfated)) {
    # extract peptidoform_id and dataset_ID
    current_peptidoform_id <- peptidoforms_potentially_sulfated$peptidoform_id[i]
    
    # the dataset ID column contains all dataset IDs separated by ,
    dataset_ids <- strsplit(peptidoforms_potentially_sulfated$dataset_ID[i], ", ")[[1]]

    # create a PDF for the current peptidoform id
    pdf(paste0("histograms_", current_peptidoform_id, ".pdf"))
    
    # plot the histograMs of each peptidoform ID within each dataset
    for (dataset_id in dataset_ids) {
        #to test loop
        dataset_id <- "PXD003115-Hs_PGRCCancerProteome-Phospho"
        # get file name and read the dataset
        file_name <- paste0(data_dir, dataset_id, "_peptidoforms.csv")
        dataset <- read.csv(file_name)

        # clean peptidoform_id in the current dataset
        dataset$peptidoform_id <- gsub("\\[|\\]", "", dataset$peptidoform_id)
        # head( dataset$peptidoform_id) - has worked

        # Filter rows with the current peptidoform_id
        filtered_data <- subset(dataset, peptidoform_id == current_peptidoform_id)

        # Generate and plot histogram
        if (nrow(filtered_data) > 0) {
            ggplot(filtered_data, aes(x = calibrated_error)) +
                geom_histogram(bins = 30, fill = "blue", color = "black") +
                ggtitle(paste("Histogram for", current_peptidoform_id, "in dataset", dataset_id)) +
                xlab("Calibrated Error") +
                ylab("Frequency")
            # Add a page break in the PDF for each histogram
            grid::grid.newpage()
        }
    }
    
    # Close the PDF device
    dev.off()
}




```
