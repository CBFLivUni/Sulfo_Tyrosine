# Number of unique instruments
num_instruments <- length(unique(datasets_metadata$instrument))
library(viridis)
# Create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "D")
color_palette
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
# create colour palette for all instruments
instruments <- unique(datasets_metadata$instrument)
# number of unique instruments
num_instruments <- length(instruments)
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "D")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
instrument_colors
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "C")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "B")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "A")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "E")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# create a colorblind-friendly palette
color_palette <- viridis::viridis(n = num_instruments, option = "D")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# Add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
# Optionally, add a title to your plot
title("Colorblind-Friendly Palette for Instruments")
library(tidyverse)
library(viridis)
library(ggplot2)
# set wd to script folder
setwd("C:/Users/jtzve/Desktop/Sufo_Tyrosine/10_confident_subset_BOI/scripts/")
# data by peptidoform is in the data dir
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/06_histograms_of_peptidoforms_of_interest_per_dataset/out/csv_tables_by_peptidoform/"
####### read in data ##############
# peptidoforms of interest metadata - subset of proteins  that could be sulfated based on CC
peptidoform_data <- read.csv("../in/potential_sY_peptidoforms_BOI.csv")
# below will be needed  to add instrument to datasets
datasets_metadata <- read.csv("../in/human_phosphobuild_metadata.csv") %>% distinct()
# convert the issue with multiple datasets split by comma into a long format by adding more rows
# head(datasets_metadata)
datasets_metadata <- datasets_metadata %>%
separate_rows(Dataset, sep = ",") %>%
distinct()
# rename columns
names(datasets_metadata) <- c("dataset_ID", "experiment_tag", "instrument", "sample_category")
# replace spaces in instrument names by _ to enable proper plotting later - some error in the gfacet wrap otherwise
datasets_metadata$instrument <- gsub(" ", "_", datasets_metadata$instrument)
######### get list of files ##############
extension = ".csv"
files_by_peptidoform <- list.files(data_dir, pattern = extension, full.names = FALSE, recursive = TRUE)
# retain peptidofrom id from the filenames
ids_in_file_names <- gsub("^merged_data_|\\.csv$", "", files_by_peptidoform)
# keep only relevant files and then generate absolute paths for input
filtered_files <- files_by_peptidoform[ids_in_file_names %in% peptidoform_data$peptidoform_id]
input_filenames <- paste0(data_dir, filtered_files)
# decide which columns to colour plots by
# columns_of_interest <- c("dataset_ID", "experiment_tag",  "instrument")
columns_of_interest <- c("instrument")
source("plot_colour_coded_histogram_fun.R")
for (column in columns_of_interest) {
# open a pdf file#
pdf(file = paste0("../out/faceted_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
column_to_colour_by = column,
mz_binwidth = 0.001)
}
dev.off()
# open a pdf file#
pdf(file = paste0("../out/stacked_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
mz_binwidth = 0.001,
column_to_colour_by = column,
layout = "stacked_bar")
}
dev.off()
}
unknowns <- data.frame()
warnings()
source("plot_colour_coded_histogram_fun.R")
for (column in columns_of_interest) {
# open a pdf file#
pdf(file = paste0("../out/faceted_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
column_to_colour_by = column,
mz_binwidth = 0.001)
}
dev.off()
# open a pdf file#
pdf(file = paste0("../out/stacked_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
mz_binwidth = 0.001,
column_to_colour_by = column,
layout = "stacked_bar")
}
dev.off()
}
warnings()
source("plot_colour_coded_histogram_fun.R")
for (column in columns_of_interest) {
# open a pdf file#
pdf(file = paste0("../out/faceted_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
column_to_colour_by = column,
mz_binwidth = 0.001)
}
dev.off()
# open a pdf file#
pdf(file = paste0("../out/stacked_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
mz_binwidth = 0.001,
column_to_colour_by = column,
layout = "stacked_bar")
}
dev.off()
}
# create colour palette for all instruments
instruments <- unique(datasets_metadata$instrument)
# number of unique instruments
num_instruments <- length(instruments)
# create a colorblind-friendly palette
color_palette <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00",
"black", "gold1", "skyblue2", "palegreen2", "#FDBF6F", "gray70",
"maroon", "orchid1", "darkturquoise", "darkorange4", "brown") [num_instruments]
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
# create a colorblind-friendly palette
color_palette <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00",
"black", "gold1", "skyblue2", "palegreen2", "#FDBF6F", "gray70",
"maroon", "orchid1", "darkturquoise", "darkorange4", "brown")[num_instruments]
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
num_instruments
# create a colorblind-friendly palette
color_palette <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00",
"black", "gold1", "skyblue2", "palegreen2", "#FDBF6F", "gray70",
"maroon", "orchid1", "darkturquoise", "darkorange4", "brown")[1:num_instruments]
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
plot_colour_coded_histogram <- function(absolute_file_path,
peptidoform_metadata,
column_to_colour_by,
mz_binwidth = 0.02,
layout = "facet",
metadata_by_dataset = datasets_metadata ) {# set as default as i wont rly customise
# first, we read in the .csv file for a peptidoform
temp_data <- read.csv(absolute_file_path)
# based on temp_data$dataset_ID we need to bin temp_data$calibrated_error into 0.02 m/z wide bins.
# find the min calibrated error, round down to nearest 0.1; and max calibrated error, round up top enarest 0.1
# this will be our x axis lims
# split the callibrated errors into bins of mz_binwidth m/z - default for mz_binwidth is 0.02
# somehow keep track of the number of values for rach dataset ID that fall in a bin, then create a "hiostogram" in the form
# of a stacked bar chart - for each m/z bin the bar should be split and coloure dby datasrt ID.
full_IDs <- strsplit(temp_data$dataset_ID, split = "-")
# clean dataset ID and keep separate from experiment tag
temp_data$dataset_ID <- sapply(full_IDs, `[`, 1) # extracts the first element
temp_data$experiment_tag <- sapply(full_IDs, `[`, 2) # extracts the second element
# replace NA values by "" to avoid future instrument assignment complications
temp_data <- temp_data %>%
mutate(
dataset_ID = replace_na(dataset_ID, ""),
experiment_tag = replace_na(experiment_tag, "")
)
#  add instrument metadata to the dataset.
temp_data$instrument <- ""
unknowns <- data.frame()
for(i in 1:nrow(temp_data)) {
current_dataset_ID <- gsub("^CPTAC_", "", temp_data$dataset_ID[i]) # get rid of CPTAC_ prefix
current_experiment_tag <- temp_data$experiment_tag[i]
match_row <- metadata_by_dataset[
metadata_by_dataset$dataset_ID == current_dataset_ID &
metadata_by_dataset$experiment_tag == current_experiment_tag,
]
if(nrow(match_row) == 1) {
temp_data$instrument[i] <- match_row$instrument
} else {
# warning(paste("Dataset ID", current_dataset_ID, "+ experiment tag not matched, attempting instrument assignment by dataset ID only."))
match_row <- metadata_by_dataset[metadata_by_dataset$dataset_ID == current_dataset_ID, ]
if (nrow(match_row) == 1) {
temp_data$instrument[i] <- match_row$instrument
} else if (nrow(match_row) > 1) {
instrument <- unique(match_row$instrument)
if (length(instrument) == 1) {
temp_data$instrument[i] <- instrument
} else {
# print(paste("Current experiment tag:", current_experiment_tag))
# print(paste("Current dataset ID:", current_dataset_ID))
# warning("More than one possible instrument, the most likely was picked, please double-check.")
instr_counts <- table(match_row$instrument)
most_common_instrument <- names(sort(instr_counts, decreasing = TRUE))[1]
temp_data$instrument[i] <- most_common_instrument
}
} else {
temp_data$instrument[i] <- "not_known"
warning(paste("No instrument found for dataset ID", current_dataset_ID, "."))
}
}
}
#
# for(i in 1:nrow(temp_data)) {
#   # extract the current row's dataset_ID and experiment_tag
#   current_dataset_ID <- temp_data$dataset_ID[i]
#   # print(current_dataset_ID)
#   current_experiment_tag <- temp_data$experiment_tag[i]
#   # print(current_experiment_tag)
#
#   # find a matching row in metadata_by_dataset
#   match_row <- metadata_by_dataset[metadata_by_dataset$dataset_ID == current_dataset_ID &
#                                    metadata_by_dataset$experiment_tag == current_experiment_tag, ]
#   # print(match_row)
#   # if a match is found, update the instrument in temp_data
#   if(nrow(match_row) == 1) {
#     temp_data$instrument[i] <- match_row$instrument
#   } else { # usually the problem when no match found is the experimental tag
#     warning("datasetd ID + experimetn tag not matched, attempting instrument assignment by dataset ID only")
#     # get the row by just matching the dataset ID
#     match_row <- metadata_by_dataset[metadata_by_dataset$dataset_ID == current_dataset_ID ,]
#
#     if (nrow(match_row) == 1) {
#
#       temp_data$instrument[i] <- match_row$instrument
#
#     } else if (nrow(match_row) > 1) { # here we could have multiple matching rows!
#       # usually same instrument in a dataset so try to narrow it down to just one
#       instrument <- unique(match_row$instrument)
#
#       if (length(instrument) == 1) {
#
#         temp_data$instrument[i] <- instrument
#
#       } else { # if more than one leave NA and stop function
#         print(current_experiment_tag)
#         print(current_dataset_ID)
#         warning("more than one possible instrument, the most likely was picked, please double-check")
#         # count how many of each instrument in match_row
#         instr_counts <- table(match_row$instrument)
#         # pick the one that appears most often
#         most_common_instrument <- names(sort(instr_counts, decreasing = TRUE))[1]
#         temp_data$instrument[i] <- most_common_instrument
#       }
#
#     } else {
#       # No matches found, instrument unknown
#       temp_data$instrument[i] <- "unknown"
#       warning("No instrument found for dataset ID ", current_dataset_ID, ".")
#
#   }
#
# }
# precalculate min and max calibrated error
min_error <- round(min(temp_data$calibrated_error) - 2*mz_binwidth, digits = 2)
max_error <- round(max(temp_data$calibrated_error) + 2*mz_binwidth, digits = 2)
# create bins to plot data by
bins <- seq(min_error, max_error, by = mz_binwidth)
# cut the calibrated errors into bins
temp_data$bin <- cut(temp_data$calibrated_error, bins, include.lowest = TRUE, labels = FALSE)
## TODO add functionality to specify column to colour by in the metadata.
## especially interested in colouring by dataset ID, experiment tag, instrument,
## and instrument sensitivity.
# ask Andy to rate instrument sensitivity as low, medium, high from what he knows
# ask Andy for input on USI generation
if (!column_to_colour_by %in% names(temp_data)) {
stop("The specified column to color by does not exist in the data frame.")
}
# aggregate data for plotting
# here we need to aggregate by ~bin + column to colourr by;
# old version:
# plot_data <- aggregate(cbind(count = calibrated_error) ~ bin + dataset_ID, data = temp_data, FUN = length)
# i guess a work around is this:
formula_text <- as.formula(paste("cbind(count = calibrated_error) ~ bin +", column_to_colour_by))
plot_data <- aggregate(formula_text, data = temp_data, FUN = length)
# get bin center for plotting instead of using bin number
plot_data$binstart <- bins[plot_data$bin]
plot_data$binend <- bins[plot_data$bin+1]
plot_data$bincenter <- (plot_data$binstart + plot_data$binend) / 2
# calculate total PSM counts per dataset
total_counts <- plot_data %>%
group_by(!!sym(column_to_colour_by)) %>% # group by column to colour by
summarise(total = sum(count))
# convert to factor
plot_data[[column_to_colour_by]] <- factor(plot_data[[column_to_colour_by]], levels = total_counts[[column_to_colour_by]])
# add to plot df and custom facet label
plot_data <- plot_data %>%
left_join(total_counts, by = column_to_colour_by) %>%
mutate(facet_label = paste0(get(column_to_colour_by), "_total_PSMs:", total)) # do for column to colour by - here we need to sue get
head(plot_data)
title_text <- gsub("^.*/|\\.csv$|^", "", absolute_file_path) # remove path and .csv
title_text <- sub("^merged_data_", "", title_text) # remove merged_data_ prefix
if (layout == "facet") {
# generate and display the plot with facets for each dataset_ID
# order to have dataset with most at the top
p <- ggplot(plot_data, aes(x = bincenter, y = count, fill = get(column_to_colour_by))) +
geom_col(width = mz_binwidth) +
facet_wrap(~reorder(facet_label, -total), ncol = 3, labeller = label_parsed) +
scale_x_continuous(name = "Calibrated Error (m/z)") +
labs(y = "Count", title = title_text) +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
strip.text.x = element_text(size = 10, hjust = 1)) +
geom_vline(xintercept = -0.0095, linetype = "dashed", color = "black")
}
if (layout == "stacked_bar") {
# create a stacked bar chart type of histogram
p <- ggplot(plot_data, aes(x = bincenter, y = count, fill = get(column_to_colour_by))) +
geom_col(position = "stack", width = mz_binwidth) +  # geom_col is used here for explicit bar widths
scale_x_continuous(name = "Calibrated Error (m/z)", breaks = seq(min(plot_data$binstart), max(plot_data$binend), by = mz_binwidth * 5)) +
labs(y = "PSM Count", title = title_text) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))+
geom_vline(xintercept = -0.0095, linetype = "dashed", color = "black")
# adjust axis limits
p <- p + expand_limits(x = c(min(plot_data$binstart), max(plot_data$binend)))
}
if (column_to_colour_by == "instrument") {
p <- p + scale_fill_manual(values = instrument_colors)
} else {
p <- p + scale_fill_brewer(palette = "Set3")
}
print(p)
return(p)
}
# pick palette by actually visualising - in future may be worth
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
source("plot_colour_coded_histogram_fun.R")
for (column in columns_of_interest) {
# open a pdf file#
pdf(file = paste0("../out/faceted_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
column_to_colour_by = column,
mz_binwidth = 0.001)
}
dev.off()
# open a pdf file#
pdf(file = paste0("../out/stacked_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
mz_binwidth = 0.001,
column_to_colour_by = column,
layout = "stacked_bar")
}
dev.off()
}
####### read in data ##############
# peptidoforms of interest metadata - subset of proteins  that could be sulfated based on CC
# peptidoform_data <- read.csv("../in/potential_sY_peptidoforms_BOI.csv")
# stricter subset where histograms were convincing
peptidoform_data <- read.csv("../in/strict_potential_sY_peptidoforms_BOI.csv")
# below will be needed  to add instrument to datasets
datasets_metadata <- read.csv("../in/human_phosphobuild_metadata.csv") %>% distinct()
# convert the issue with multiple datasets split by comma into a long format by adding more rows
# head(datasets_metadata)
datasets_metadata <- datasets_metadata %>%
separate_rows(Dataset, sep = ",") %>%
distinct()
# rename columns
names(datasets_metadata) <- c("dataset_ID", "experiment_tag", "instrument", "sample_category")
# replace spaces in instrument names by _ to enable proper plotting later - some error in the gfacet wrap otherwise
datasets_metadata$instrument <- gsub(" ", "_", datasets_metadata$instrument)
######### get list of files ##############
extension = ".csv"
files_by_peptidoform <- list.files(data_dir, pattern = extension, full.names = FALSE, recursive = TRUE)
# retain peptidofrom id from the filenames
ids_in_file_names <- gsub("^merged_data_|\\.csv$", "", files_by_peptidoform)
# keep only relevant files and then generate absolute paths for input
filtered_files <- files_by_peptidoform[ids_in_file_names %in% peptidoform_data$peptidoform_id]
input_filenames <- paste0(data_dir, filtered_files)
# decide which columns to colour plots by
# columns_of_interest <- c("dataset_ID", "experiment_tag",  "instrument")
columns_of_interest <- c("instrument")
source("plot_colour_coded_histogram_fun.R")
source("plot_colour_coded_histogram_fun.R")
library(ggsci)
color_palette <- pal_npg()(num_instruments)
library(scico)
install.packages("scico")
library(scico)
color_palette <- scico(n = num_instruments, palette = "batlow"))
color_palette <- scico(n = num_instruments, palette = "batlow")
# assign colors to each instrument
instrument_colors <- setNames(color_palette, instruments)
# pick palette by actually visualising - in future may be worth
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, length(instruments)), axes=FALSE)
# add a rectangle for each color, along with the instrument name as text
for(i in 1:length(instruments)) {
rect(0, i-1, 1, i, col=instrument_colors[i], border="white")
text(0.5, i-0.5, instruments[i], cex=0.7)
}
library(wesanderson)
install.packages("westanderson")
library(wesanderson)
color_palette <- wes_palette(name = "GrandBudapest1", n = num_instruments)
library(colorblindr)
install.packages("colorblindr")
remotes::install_github("wilkelab/cowplot")
remotes::install_github("clauswilke/colorblindr")
# create a colorblind-friendly palette
color_palette <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00",
"black", "gold1", "skyblue2", "palegreen2", "#FDBF6F", "gray70",
"maroon", "orchid1", "darkturquoise", "darkorange4", "brown")[1:num_instruments]
simulate_cvd(color_palette)
library(colorblindr)
simulate_cvd(color_palette)
source("plot_colour_coded_histogram_fun.R")
for (column in columns_of_interest) {
# open a pdf file#
pdf(file = paste0("../out/faceted_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
column_to_colour_by = column,
mz_binwidth = 0.001)
}
dev.off()
# open a pdf file#
pdf(file = paste0("../out/stacked_plots_by_", column, ".pdf"),
width = 8.27, height = 11.69) #A4 format
for (file in input_filenames) {
# add plot to pdf
plot_colour_coded_histogram(absolute_file_path = file,
peptidoform_metadata = peptidoform_data,
mz_binwidth = 0.001,
column_to_colour_by = column,
layout = "stacked_bar")
}
dev.off()
}
