# benchmark_counting_PTMs_500rows <- benchmark_counting_PTMs
autoplot(benchmark_counting_PTMs_224276rows)
df <- df2[5000, ]
df <- df2[1:5000, ]
benchmark_counting_PTMs <- microbenchmark(
old_code = {
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 2  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
new_code = {
# #this uses stringi and parallel computing
# count_PTMs <- function(peptide, PTMs_vector) {
#   sapply(PTMs_vector, function(ptm) stri_count_fixed(peptide, ptm))
# }
#
#this uses stringr and old function
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- detectCores() - 2  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
times = 10 # You can adjust the number of times each expression is evaluated
)
autoplot(benchmark_counting_PTMs)
benchmark_counting_PTMs <- microbenchmark(
old_code = {
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 2  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
new_code = {
# #this uses stringi and parallel computing
# count_PTMs <- function(peptide, PTMs_vector) {
#   sapply(PTMs_vector, function(ptm) stri_count_fixed(peptide, ptm))
# }
#
#this uses stringr and old function
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 8  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
times = 100 # You can adjust the number of times each expression is evaluated
)
autoplot(benchmark_counting_PTMs)
## benchmarkign number of cores
df2 <- df
df <- df2[1:500, ]
benchmark_counting_PTMs <- microbenchmark(
old_code = {
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 1  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
new_code = {
# #this uses stringi and parallel computing
# count_PTMs <- function(peptide, PTMs_vector) {
#   sapply(PTMs_vector, function(ptm) stri_count_fixed(peptide, ptm))
# }
#
#this uses stringr and old function
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 8  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
},
times = 100 # You can adjust the number of times each expression is evaluated
)
autoplot(benchmark_counting_PTMs)
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
# Setting up parallel processing
no_cores <- 1  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
benchmark_counting_PTMs <- microbenchmark(
old_code = {
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
},
new_code = {
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
},
times = 100 # You can adjust the number of times each expression is evaluated
)
# Stop the cluster
stopCluster(cl)
autoplot(benchmark_counting_PTMs)
twocores <- benchmark_counting_PTMs
# Setting up parallel processing
no_cores <- 8  # Leave a couple of cores free for system stability
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Exporting necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
benchmark_counting_PTMs <- microbenchmark(
old_code = {
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
},
new_code = {
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
},
times = 100 # You can adjust the number of times each expression is evaluated
)
# Stop the cluster
stopCluster(cl)
autoplot(benchmark_counting_PTMs)
eightcores
eightcores <- benchmark_counting_PTMs
eightcores
str(eightcores)
cbind(twocores, eightcores)
new <- cbind(twocores, eightcores)
autoplot(new)
new
autoplot(benchmark_counting_PTMs)
autoplot(twocores)
autoplot(eightcores)
autoplot(twocores)
autoplot(eightcores)
twocores$expr
##### get datasets calibrated data to work with ##########
# get all calibrated tsvs
wd <- paste0(getwd(), "/")
extension = ".pep_calibrated.tsv"
calibrated_files <- list.files(wd, pattern = extension, full.names = FALSE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
calibrated_data[[1]] <- read.csv(calibrated_files[[1]], sep = "\t")
calibrated_data[[1]] <- read.csv(calibrated_files[[8]], sep = "\t")
calibrated_files[[8]]
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
calibrated_data[[1]] <- read.csv(calibrated_files[[8]], sep = "\t")
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# assign this to our list
names(calibrated_data) <- stripped_filenames
########## filter all data to only include peptides with phospho PTMs ##########
#determine which columns of the data you would like to continue workinbg with.
colstokeep <- c("ppm_error", "da_error", "calibrated_error", "peptide",
"mod_peptide") # must have this col to filter!
# determine what PTMs are of interest
PTMs_of_interest = c("S[167]", "T[181]", "Y[243]") # here phosphorylation of S, T, and Y
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
pepcols = colstokeep,
PTMs_of_interest = PTMs_of_interest)
}
source("PTM_filtering_fun.R") # filter peptides by PTMs to only include phosphorylated - my function
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
pepcols = colstokeep,
PTMs_of_interest = PTMs_of_interest)
}
# add names just in case
names(filtered_data) <- stripped_filenames[[8]]
names(filtered_data)
####### summarise data by unique peptidoform ##########
# define which parameters you want summarised by peptidoform
columns_of_interest <- c("calibrated_error") # e.g. cols for histogram plotting
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
df = filtered_data[[1]]
columns_to_summarise =  columns_of_interest
pepcols = pepcols
outname = output_name
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[8])
outname = output_name
if (is.na(outname)) {
df_name <- deparse(substitute(df)) # store the df name to use for file namings later
# for some reason calling this at a later stage results in an error when trying to write files
} else {
df_name <- outname
}
print("Getting list of unique PTM modifications present in the dataset...")
modifications_withamino <- str_extract_all(df$mod_peptide, "[A-Za-z]\\[[0-9]+\\]") %>%
unlist() %>% # flatten list to vector
unique() %>% # get only unique ones
sort() # sort them
# define a function to use for PTM counting for each type of PTM present in the data
count_PTMs <- function(peptide, PTMs_vector) {
# for a vector that contains list of PTMs detected in the data
sapply(PTMs_vector, function(ptm) str_count(peptide, fixed(ptm))) #count the number of times each PTM appears
}
print("Counting PTMs for each peptide... This may take a little while.")
# # getting the matrix of counts for each PTM
# PTM_counts <- apply(df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# # this part of the function is a bit slow! lets test it with parallel computing?
# Setting up parallel processing
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
# Load required libraries on each worker node
clusterEvalQ(cl, library(stringr)) # or library(stringi)
# Export necessary objects and functions to each worker
clusterExport(cl, varlist = c("count_PTMs", "modifications_withamino", "df"))
# Perform the counting in parallel
PTM_counts <- parApply(cl, df, 1, function(row) count_PTMs(row["mod_peptide"], modifications_withamino))
# Stop the cluster
stopCluster(cl)
View(PTM_counts)
# transposing the matrix so rownames match rownames of data
PTM_counts_matrix <- t(PTM_counts)
View(PTM_counts_matrix)
# collapsing the matrix to a vector of strings
PTM_counts_string <- apply(PTM_counts_matrix, 1, paste, collapse="_")
# getting the scipher for which position correcponds to which PTM in case we need to decode in the future
PTM_scipher <- paste(colnames(PTM_counts_matrix), collapse="_")
# Add a column to the dataframe with PTM counts code
df$PTM_counts <- PTM_counts_string
# to keep the schipher, we populate an entire column with it
n <- nrow(df)
df$PTM_counts_scipher <- rep(PTM_scipher, n)
# next we need to assemble peptidoforms by peptide sequence and PTM count
print("Generating peptidoform identifiers...")
peptidoform_id <- paste(df$peptide, df$PTM_counts, sep = "_")
# check if it works correctly
# head(peptidoform_id)
df$peptidoform_id <- peptidoform_id
View(df)
install.packages("hash")
library(hash)
dict <- hash()
rm(peptidoform_id)
peptidoform_ids <- paste(df$peptide, df$PTM_counts, sep = "_")
# check if it works correctly
# head(peptidoform_id)
df$peptidoform_ids <- peptidoform_ids
# we already have the peptidoform ids vecotr in our env
calibrated_mass_shifts <- df$calibrated_error
# Populate the hash
for (i in seq_along(peptidoform_ids)) {
id <- peptidoform_ids[i]
shift <- calibrated_mass_shifts[i]
if (!has.key(id, dict)) {
dict[[id]] <- c()
}
dict[[id]] <- c(dict[[id]], shift)
}
warnings()
View(dict)
dict2 <- split(df$calibrated_error, df$peptidoform_ids)
View(dict)
head(dict2)
# Aggregate shifts into a single string for each id
dict3 <- aggregate(shift ~ id, data = df, FUN = function(x) paste(x, collapse = ","))
View(dict3)
# Convert the result to a named vector or list if needed
dict_vector <- setNames(dict$shift, dict$id)
View(dict3)
# Convert shifts to a single string for each id
dict_vector <- tapply(df$calibrated_error, df$peptidoform_id, FUN = function(x) paste(x, collapse = ","))
dict_vector[1:6]
head(dict2)
str(dict2[1])
str(dict_vector[1])
# Aggregate shifts into a single string for each id
dict3 <- aggregate(calibrated_error ~ peptidoform_id, data = df, FUN = function(x) paste(x, collapse = ","))
head(dict3)
View(dict3)
str(dict3[1])
str(dict3)
str(dict3[1,2])
View(dict3)
str(dict2)
str(dict2[1])
str(dict3[1,1])
# Convert the result to a named vector or list if needed
dict_vector <- setNames(dict$shift, dict$id)
source("PTM_filtering_fun.R") # filter peptides by PTMs to only include phosphorylated - my function
source("Summarise_by_peptidoform_fun2.R") # for each dataset summarise the mass shift for each unique peptidoform - my function
##### get datasets calibrated data to work with ##########
# get all calibrated tsvs
wd <- paste0(getwd(), "/")
extension = ".pep_calibrated.tsv"
calibrated_files <- list.files(wd, pattern = extension, full.names = FALSE, recursive = TRUE)
# extract the folder paths for hist plot f-n
folders <- dirname(calibrated_files)
# and the filenames for input in plot histograms f-n by Andy
input_filenames <- basename(calibrated_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
calibrated_data <- list()
for (i in 1:length(calibrated_files)) {
calibrated_data[[i]] <- read.csv(calibrated_files[[i]], sep = "\t")
}
# we want to add names to the dataframes so they are used e.g. when writing csvs.
# first strip everythign after and including _interact .... .tsv
stripped_filenames <- gsub("_interact.*", "", input_filenames)
# for every calibrated dataset
filtered_data <- list()
for (i in 1:length(calibrated_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
filtered_data[[i]] <- FilterPTMs(df = calibrated_data[[i]],
pepcols = colstokeep,
PTMs_of_interest = PTMs_of_interest)
}
View(Summarise_By_Peptidoform)
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
####### summarise data by unique peptidoform ##########
# define which parameters you want summarised by peptidoform
columns_of_interest <- c("calibrated_error") # e.g. cols for histogram plotting
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
source("Summarise_by_peptidoform_fun2.R") # for each dataset summarise the mass shift for each unique peptidoform - my function
####### summarise data by unique peptidoform ##########
# define which parameters you want summarised by peptidoform
columns_of_interest <- c("calibrated_error") # e.g. cols for histogram plotting
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
names(filtered_data) <- stripped_filenames
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
####### summarise data by unique peptidoform ##########
# define which parameters you want summarised by peptidoform
columns_of_interest <- c("calibrated_error") # e.g. cols for histogram plotting
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
names(filtered_data) <- stripped_filenames
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
peptidoform_id_fun2 <- peptidoform_id_summaries
peptidoform_id_fun3 <- list()
source("Summarise_by_peptidoform_fun2.R") # for each dataset summarise the mass shift for each unique peptidoform - my function
####### summarise data by unique peptidoform ##########
# define which parameters you want summarised by peptidoform
columns_of_interest <- c("calibrated_error") # e.g. cols for histogram plotting
pepcols <-  c("peptide", "mod_peptide") # cols with peptide and PTM data
# these are defaults, here just for ease
peptidoform_id_summaries <- list()
names(filtered_data) <- stripped_filenames
for (i in 1:length(filtered_data)) {
#apply the PTM filtering function to only include peptides with phosphtylation
output_name <- names(filtered_data[i])
print(output_name)
peptidoform_id_summaries[[i]] <- Summarise_By_Peptidoform(df = filtered_data[[i]],
columns_to_summarise =  columns_of_interest,
pepcols = pepcols,
outname = output_name)
}
peptidoform_id_fun3 <- peptidoform_id_summaries
View(peptidoform_id_fun3)
peptidoform_id_fun3[[1]]
test <- peptidoform_id_fun3[[1]]
str(test[[1]])
str(test[1])
str(test[17])
str(test[8])
str(test[7])
123.3/142.2
# Function to safely get values from a vector (handles NA)
safe_get <- function(vec, key) {
if (is.na(vec[key]) || is.null(vec[key])) {
return("")
} else {
return(vec[key])
}
}
# Function to merge two dict_vectors
merge_two_dict_vectors <- function(dict_vector_1, dict_vector_2) {
all_keys <- unique(c(names(dict_vector_1), names(dict_vector_2)))
merged_dict_vector <- sapply(all_keys, function(key) {
paste(c(safe_get(dict_vector_1, key), safe_get(dict_vector_2, key)), collapse = ",")
})
names(merged_dict_vector) <- all_keys
return(merged_dict_vector)
}
test_list[peptidoform_id_fun2[[1:3]]]
test_list <- peptidoform_id_fun2[[1:3]]
test_list <- peptidoform_id_fun2[1:3]
merged_dict_vector <- Reduce(merge_two_dict_vectors, test_list)
option1 <- read.csv("master_peptidoform_errors.csv")
head(option1)
str(option1$calibrated_error)
summary(option1)
length(option1$peptidoform_id) == length(unique(option1$peptidoform_id))
length(unique(option1$peptidoform_id))
