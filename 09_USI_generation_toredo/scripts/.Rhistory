# Replace the chosen "[Phospho]" with ""
last_segment <- strsplit(last_segment, split = "")
last_segment
length("[phospho]")
length(strsplit("[phospho]", split = ""))
strsplit("[phospho]", split = "")
#  engineer this tomorrow
substr(string, start, end)
usi
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
!modified
str_detect(last_segment, "Y(?!\\{)")
str_detect(last_segment, "\\[Phospho\\]")
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
n
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
y_positions
# choose random y to replace
chosen_y <- sample(y_positions, 1)
chosen_y
# split the sting into letters
last_segment <- strsplit(last_segment, split = "")
last_segment
# split the sting into letters
last_segment <- unlist(strsplit(last_segment, split = ""))
last_segment <- parts[6]
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
# choose random y to replace
chosen_y <- sample(y_positions, 1)
# split the sting into letters
last_segment <- unlist(strsplit(last_segment, split = ""))
last_segment
chosen_y
# replace the chose tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
sulfotyrosine <- "Y{Sulfo}"
# replace the chose tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
last_segment
# re-paste together
new_segment <- lapply(last_segment, paste0(x))
last_segment <- parts[6]
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
# choose random y to replace
chosen_y <- sample(y_positions, 1)
chosen_y
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "")
sulfotyrosine <- "Y{Sulfo}"
last_segment
# replace the chose tyrosine with a sulfotyrosine
last_segment[[chosen_y]] <-  sulfotyrosine
last_segment
last_segment <- parts[6]
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "")
sulfotyrosine <- "Y{Sulfo}"
# replace the chose tyrosine with a sulfotyrosine
last_segment[[1]][chosen_y] <-  sulfotyrosine
last_segment
usi
# re-paste together
new_segment <- lapply(last_segment, paste0(x))
# re-paste together
new_segment <- lapply(last_segment, paste0)
new_segment
# re-paste together
new_segment <- lapply(last_segment[[1]], paste0)
new_segment
# re-paste together
new_segment <- lapply(last_segment[1], paste0)
new_segment
# re-paste together
new_segment <- paste0(last_segment)
new_segment
# re-paste together
new_segment <- paste0(last_segment, collapse = "")
new_segment
last_segment
# re-paste together
new_segment <- paste(last_segment, collapse = "")
new_segment
last_segment
# re-paste together
new_segment <- paste(last_segment, collapse = "")
new_segment
last_segment <- parts[6]
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chose tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
last_segment
# re-paste together
new_segment <- paste(last_segment, collapse = "")
new_segment
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
phospho_positions
chosen_phospho <- sample(phospho_positions, 1)
chosen_phospho
new_segment
# ger the new segment as vector again
temp_segment <- strsplit(new, split = "") %>% unlist()
# ger the new segment as vector again
temp_segment <- strsplit(new_segment, split = "") %>% unlist()
temp_segment
chosen_phospho
length(strsplit("[phospho]", split = ""))
strsplit("[phospho]", split = "")
chosen_phospho
temp_segment[chosen_phospho]
temp_segment[chosen_phospho:chosen_phospho+9]
temp_segment[chosen_phospho:(chosen_phospho+9)]
temp_segment[chosen_phospho:(chosen_phospho+8)]
temp_segment[chosen_phospho:(chosen_phospho+8)] <- ""
temp_segment
# reconstruct
new_segment <- paste(temp_segment, collapse = "")
new_segment
modify_USI <- function(usi) {
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
# replace a random occurance of "Y[Phospho]" with "Y{Sulfo}" if Y[Phospho] exists
if (str_detect(last_segment, "Y\\[Phospho\\]")) {
phospho_positions <- gregexpr("Y\\[Phospho\\]", last_segment)[[1]]
if (length(phospho_positions) > 0) {
# choose a random position to replace
chosen_position <- sample(phospho_positions, 1)
last_segment <- sub("Y\\[Phospho\\]", "Y{Sulfo}", last_segment, perl = TRUE)
# reconstruct usi and return
parts[6] <- last_segment
return(paste(parts, collapse = ":"))
}
}
# If not modified yet, check for "Y" not followed by "{" and "[Phospho]" - i.e. there is room for mdoification
if (!modified && str_detect(last_segment, "Y(?!\\{)") && str_detect(last_segment, "\\[Phospho\\]")) {
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
if (length(y_positions) > 0) {
# choose random y to replace
chosen_y <- sample(y_positions, 1)
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
} else {
# if all Ys have a sulfo already, return an empty string for the new USI
return( "")
}
# noe that we have added a sulfo, we need to remove a phospho
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
# chose random one to replace
chosen_phospho <- sample(phospho_positions, 1)
# ger the new segment as vector again
temp_segment <- strsplit(new_segment, split = "") %>% unlist()
# replace the chosen phospho with nothing
temp_segment[chosen_phospho:(chosen_phospho+8)] <- ""
# reconstruct
new_segment <- paste(temp_segment, collapse = "")
modified <- TRUE
}
}
modify_USI <- function(usi) {
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
# replace a random occurance of "Y[Phospho]" with "Y{Sulfo}" if Y[Phospho] exists
if (str_detect(last_segment, "Y\\[Phospho\\]")) {
phospho_positions <- gregexpr("Y\\[Phospho\\]", last_segment)[[1]]
if (length(phospho_positions) > 0) {
# choose a random position to replace
chosen_position <- sample(phospho_positions, 1)
last_segment <- sub("Y\\[Phospho\\]", "Y{Sulfo}", last_segment, perl = TRUE)
# reconstruct usi and return
parts[6] <- last_segment
return(paste(parts, collapse = ":"))
}
}
# If not modified yet, check for "Y" not followed by "{" and "[Phospho]" - i.e. there is room for mdoification
if (!modified && str_detect(last_segment, "Y(?!\\{)") && str_detect(last_segment, "\\[Phospho\\]")) {
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
if (length(y_positions) > 0) {
# choose random y to replace
chosen_y <- sample(y_positions, 1)
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
} else {
# if all Ys have a sulfo already, return an empty string for the new USI
return( "")
}
# noe that we have added a sulfo, we need to remove a phospho
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
# chose random one to replace
chosen_phospho <- sample(phospho_positions, 1)
# ger the new segment as vector again
temp_segment <- strsplit(new_segment, split = "") %>% unlist()
# replace the chosen phospho with nothing
temp_segment[chosen_phospho:(chosen_phospho+8)] <- ""
# reconstruct
new_segment <- paste(temp_segment, collapse = "")
modified <- TRUE
}
# if no modifications were made, return an empty string
if (!modified) {
return("")
}
# otherwise, reassemble the USI with the modified last segment
parts[6] <- new_segment
return(paste(parts, collapse = ":"))
}
usi
usi1 <- modify_USI (usi)
usi1
usi2 <- modify_USI (usi1)
# split the USI string to work with the last segment
parts <- str_split(usi1, ":")[[1]]
parts
last_segment <- parts[6]
str_detect(last_segment, "Y\\[Phospho\\]")
!modified && str_detect(last_segment, "Y(?!\\{)") && str_detect(last_segment, "\\[Phospho\\]")
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
y_positions
# choose random y to replace
chosen_y <- sample(y_positions, 1)
chosen_y
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
new_segment
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
# chose random one to replace
chosen_phospho <- sample(phospho_positions, 1)
phospho_positions
chosen_phospho
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
# chose random one to replace
chosen_phospho <- sample(phospho_positions, 1)
chosen_phospho
y_positions[1]
y_positions
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
if (length(y_positions) == 0) {
return("")
} else if (length(y_positions) == 1) {
chosen_y <- y_positions[1]
} else {
# choose random y to replace
chosen_y <- sample(y_positions, 1)
}
chosen_y
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
new_segment
modify_USI <- function(usi) {
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
# replace a random occurance of "Y[Phospho]" with "Y{Sulfo}" if Y[Phospho] exists
if (str_detect(last_segment, "Y\\[Phospho\\]")) {
phospho_positions <- gregexpr("Y\\[Phospho\\]", last_segment)[[1]]
if (length(phospho_positions) > 0) {
# choose a random position to replace
chosen_position <- sample(phospho_positions, 1)
last_segment <- sub("Y\\[Phospho\\]", "Y{Sulfo}", last_segment, perl = TRUE)
# reconstruct usi and return
parts[6] <- last_segment
return(paste(parts, collapse = ":"))
}
}
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
if (length(y_positions) == 0) {
return("")
} else if (length(y_positions) == 1) {
chosen_y <- y_positions[1]
} else {
# choose random y to replace
chosen_y <- sample(y_positions, 1)
}
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
# now that we have added a sulfo, we need to remove a phospho
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
if (length(phospho_positions) == 0) {
return("")
} else if (length(phospho_positions) == 1) {
chosen_phospho <- phospho_positions[1]
} else {
# choose random phospho to replace
chosen_phospho <- sample(phospho_positions, 1)
}
# ger the new segment as vector again
temp_segment <- strsplit(new_segment, split = "") %>% unlist()
# replace the chosen phospho with nothing
temp_segment[chosen_phospho:(chosen_phospho+8)] <- ""
# reconstruct
new_segment <- paste(temp_segment, collapse = "")
modified <- TRUE
# if no modifications were made, return an empty string
if (!modified) {
return("")
}
# otherwise, reassemble the USI with the modified last segment
parts[6] <- new_segment
return(paste(parts, collapse = ":"))
}
usi
usi1 <- modify_USI (usi)
usi1
usi2 <- modify_USI (usi1)
usi2
usi3 <- modify_USI (usi2)
modify_USI <- function(usi) {
# split the USI string to work with the last segment
parts <- str_split(usi, ":")[[1]]
last_segment <- parts[6]
modified <- FALSE
# replace a random occurance of "Y[Phospho]" with "Y{Sulfo}" if Y[Phospho] exists
if (str_detect(last_segment, "Y\\[Phospho\\]")) {
phospho_positions <- gregexpr("Y\\[Phospho\\]", last_segment)[[1]]
if (length(phospho_positions) > 0) {
# choose a random position to replace
chosen_position <- sample(phospho_positions, 1)
last_segment <- sub("Y\\[Phospho\\]", "Y{Sulfo}", last_segment, perl = TRUE)
# reconstruct usi and return
parts[6] <- last_segment
return(paste(parts, collapse = ":"))
}
}
if (!modified && str_detect(last_segment, "Y(?!\\{)") && str_detect(last_segment, "\\[Phospho\\]")) {
# Find all "Y" not followed by "{"
y_positions <- gregexpr("Y(?!\\{)", last_segment, perl = TRUE)
y_positions <- y_positions[[1]][1:length(y_positions[[1]])]
if (length(y_positions) == 0) {
return("")
} else if (length(y_positions) == 1) {
chosen_y <- y_positions[1]
} else {
# choose random y to replace
chosen_y <- sample(y_positions, 1)
}
# split the sting into a vector fo letters
last_segment <- strsplit(last_segment, split = "") %>% unlist()
sulfotyrosine <- "Y{Sulfo}"
# replace the chosen tyrosine with a sulfotyrosine
last_segment[chosen_y] <-  sulfotyrosine
# re-paste together
new_segment <- paste(last_segment, collapse = "")
# now that we have added a sulfo, we need to remove a phospho
# Find all "[Phospho]" in this new segment
phospho_positions <- gregexpr("\\[Phospho\\]", new_segment)[[1]][1:length(gregexpr("\\[Phospho\\]", new_segment)[[1]])]
if (length(phospho_positions) == 0) {
return("")
} else if (length(phospho_positions) == 1) {
chosen_phospho <- phospho_positions[1]
} else {
# choose random phospho to replace
chosen_phospho <- sample(phospho_positions, 1)
}
# ger the new segment as vector again
temp_segment <- strsplit(new_segment, split = "") %>% unlist()
# replace the chosen phospho with nothing
temp_segment[chosen_phospho:(chosen_phospho+8)] <- ""
# reconstruct
new_segment <- paste(temp_segment, collapse = "")
modified <- TRUE
}
# if no modifications were made, return an empty string
if (!modified) {
return("")
}
# otherwise, reassemble the USI with the modified last segment
parts[6] <- new_segment
return(paste(parts, collapse = ":"))
}
usi
usi1 <- modify_USI (usi)
usi1
usi2 <- modify_USI (usi1)
usi2
usi3 <- modify_USI (usi2)
usi3
library(tidyverse)
source(file = "generate_USI_fun.R")
setwd("C:/Users/jtzve/Desktop/Sufo_Tyrosine/09_USI_generation/scripts")
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/06_histograms_of_peptidoforms_of_interest_per_dataset/out/csv_tables_by_peptidoform/"
# get the files we are interested in read in.
# we only want ones with convincing histogram and likely protein ID based on cellular localisation
metadata <- read.csv("../in/potential_sulfo_peptidoforms_annotated.csv")
peptidoforms_of_interst <- metadata[metadata$convincing_histogram_alldatasets == "y" &
metadata$convincing_protein_subcellular_location == "y", "peptidoform_id"]
files_of_interst <- paste0(data_dir, "merged_data_", peptidoforms_of_interst, ".csv")
files_list <- list()
for (i in (1: length(files_of_interst))) {
files_list[[i]] <- read.csv(files_of_interst[i])
}
test <- files_list[[1]]
files_with_USIs_list <- list()
for (i in (1: length(files_of_interst))) {
files_with_USIs_list[[i]] <- generate_USI(files_list[[i]])
}
all_data <- files_with_USIs_list[[1]]
for (i in (2: length(files_of_interst))) {
all_data <- rbind(all_data,files_with_USIs_list[[i]] )
}
source(file = "generate_USI_fun.R")
setwd("C:/Users/jtzve/Desktop/Sufo_Tyrosine/09_USI_generation/scripts")
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/06_histograms_of_peptidoforms_of_interest_per_dataset/out/csv_tables_by_peptidoform/"
# get the files we are interested in read in.
# we only want ones with convincing histogram and likely protein ID based on cellular localisation
metadata <- read.csv("../in/potential_sulfo_peptidoforms_annotated.csv")
peptidoforms_of_interst <- metadata[metadata$convincing_histogram_alldatasets == "y" &
metadata$convincing_protein_subcellular_location == "y", "peptidoform_id"]
files_of_interst <- paste0(data_dir, "merged_data_", peptidoforms_of_interst, ".csv")
files_list <- list()
for (i in (1: length(files_of_interst))) {
files_list[[i]] <- read.csv(files_of_interst[i])
}
test <- files_list[[1]]
files_with_USIs_list <- list()
for (i in (1: length(files_of_interst))) {
files_with_USIs_list[[i]] <- generate_USI(files_list[[i]])
}
all_data <- files_with_USIs_list[[1]]
for (i in (2: length(files_of_interst))) {
all_data <- rbind(all_data,files_with_USIs_list[[i]] )
}
all_data$protein_ID <- ""
all_data$protein_name <- ""
all_data$known_sulfated <- ""
all_colnames <- colnames(all_data)
collnames_to_add_to_end <- all_colnames[1:24]
all_data_reorganised <- all_data[, c("peptidoform_id",
"known_sulfated",
"USI_workaround",
"USI_with_one_sulfo",
"USI_with_two_sulfo",
"calibrated_error",
"protein_ID",
"protein_name",
"dataset_ID",
collnames_to_add_to_end)]
# populate protein ID and protein name based on matching peptidoform ID:
# if all_data_reorganised$peptidoform_id matches  metadata$peptidoform_id,
#
# populate all_data_reorganised$protein_ID with values from the same row for metadata$cleaned_protein_IDs
# and populate all_data_reorganised$protein_name with values from the same row for metadata$Protein.names
#
all_data_reorganised <- all_data_reorganised %>%
left_join(metadata %>%
select(peptidoform_id, cleaned_protein_IDs, Protein.names),
by = "peptidoform_id") %>%
mutate(protein_ID = cleaned_protein_IDs,
protein_name = Protein.names) %>%
select(-cleaned_protein_IDs, -Protein.names)
View(all_data_reorganised)
write.csv(all_data_reorganised, file = "../out/USIs_to_share_v3.csv", row.names = FALSE)
