clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)
# process each sublist in background_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the background_cleaned_IDs list to then add to our data frame
flattened_background_cleaned_IDs <- sapply(background_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_background$cleaned_protein_IDs <- flattened_background_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_background_inSwissProt <- tyrosines_containing_background[tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_background_inSwissProt, file = "../out/medium_bins/tyrosine_containing_background_inSwissProt_2.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# also write the ones with no hit
tyrosines_containing_background_UNMATCHED <- tyrosines_containing_background[!tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
write.table(tyrosines_containing_background_UNMATCHED, file = "../out/medium_bins/tyrosine_containing_background_UNMATCHED_2.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# 85 of our background IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
# subset to only include these who do
background <- tyrosines_containing_background_inSwissProt[tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]
# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(background$cleaned_protein_IDs, Uniprot$uniprotswissprot)
# Extract corresponding ENSEMBL Gene IDs
background_genes <- Uniprot$ensembl_gene_id[matched_indices]
# Remove NAs if any (in case some SwissProt IDs didn't have a match)
background_genes <- na.omit(background_genes)
# subset to only include these who do
foreground <- tyrosines_containing_foreground_inSwissProt[tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]
# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(foreground$cleaned_protein_IDs, Uniprot$uniprotswissprot)
# Extract corresponding ENSEMBL Gene IDs
foreground_genes <- Uniprot$ensembl_gene_id[matched_indices]
# Remove NAs if any (in case some SwissProt IDs didn't have a match)
foreground_genes <- na.omit(foreground_genes)
# 0 of our foreground IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
goplot(cluster_GO_MF)
goplot(cluster_GO_MF)
barplot(cluster_GO_MF)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC)
GO_term_dataframe_CC
goplot(cluster_GO_MF)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
goplot(cluster_GO_BP)
barplot(cluster_GO_BP)
library(GOSemSim)
library(enrichplot)
# NB: treeplot might not be a good choice as we have a small number of enriched terms!
# Use function 'godata' to create a GO similarity data object
# since BP had no significant hits lets only do it for MF; CC only had 3 GO terms
GO_similarity_MF <- godata('org.Hs.eg.db', ont="MF")
### to fix Error in offspring.tbl_tree_item(.data = .data, .node = .node, tiponly = tiponly,  : could not find function "offspring.tbl_tree_item" I copied this solution from: https://github.com/YuLab-SMU/enrichplot/issues/249
nodeid.tbl_tree <- utils::getFromNamespace("nodeid.tbl_tree", "tidytree")
rootnode.tbl_tree <- utils::getFromNamespace("rootnode.tbl_tree", "tidytree")
offspring.tbl_tree <- utils::getFromNamespace("offspring.tbl_tree", "tidytree")
offspring.tbl_tree_item <- utils::getFromNamespace(".offspring.tbl_tree_item", "tidytree")
library(tidytree)
offspring.tbl_tree_item <- utils::getFromNamespace(".offspring.tbl_tree_item", "tidytree")
library(tidyverse)
offspring.tbl_tree_item <- utils::getFromNamespace(".offspring.tbl_tree_item", "tidytree")
child.tbl_tree <- utils::getFromNamespace("child.tbl_tree", "tidytree")
parent.tbl_tree <- utils::getFromNamespace("parent.tbl_tree", "tidytree")
# Add similarity matrix to the enrichment result
cluster_GO_tree <- pairwise_termsim(cluster_GO_MF, method = "Wang", semData = GO_similarity_MF)
treeplot(cluster_GO_tree)
cluster_GO_tree
# I might need entrez IDs, otherwise I get NULL
library(biomaRt)
library(ggplot2)
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
foreground_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
filters = 'ensembl_gene_id',
values = foreground_genes,
mart = ensembl)
background_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
filters = 'ensembl_gene_id',
values = background_genes,
mart = ensembl)
# make sure to convert to character too!
foreground_entrez_ids <- as.character(na.omit(foreground_entrez$entrezgene_id))
background_entrez_ids <- as.character(na.omit(background_entrez$entrezgene_id))
kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 0.5, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
dotplot(kegg_enrichment, showCategory = 10, font.size = 8) # returns only top 2
kegg_enrichment
kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 1, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
kegg_enrichment
# do dotplot manually
# extract df
KEGG_df <- kegg_enrichment@result
View(KEGG_df)
# filter down to just p<0.05
KEGG_Significant_Pathways <- KEGG_df[KEGG_df$pvalue <0.05,]
names(KEGG_Significant_Pathways)
KEGG_Significant_Pathways$GeneRatio <- sapply(strsplit(KEGG_Significant_Pathways$GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))
ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
geom_point(aes(size = Count, color = pvalue)) +
scale_color_gradient(low = "red", high = "blue") +
labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
theme_bw() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
plot.title = element_text(hjust = 0.5)
) +
ggtitle("KEGG Pathways with p<0.05")
ggsave("../out/medium_bins/KEGG_dotplot_bw_DECOY.png", plot = last_plot(), width = 6, height = 4, dpi = 300)
KEGG_Significant_Pathways
View(kegg_enrichment)
View(KEGG_Significant_Pathways)
lenghth(unique(tyrosines_containing_background_inSwissProt$protein))
length(unique(tyrosines_containing_background_inSwissProt$protein))
library(ReactomePA)
reactome_ORA <- enrichPathway(gene=foreground_entrez_ids,
universe=background_entrez_ids,
pvalueCutoff = 1, readable=TRUE)
reactome_ORA
#no hits at pcutoff 0.05
head(reactome_ORA)
library(tidyverse)
library(stringr)
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/02_medium bins/"
gc()
bin_of_interest <- cleaned_postGMM_data[["mz_-0.013_-0.007"]]
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y2", bin_of_interest$peptidoform_id), ]
# Save as a TSV file
write.table(tyrosines_containing_foreground, file = paste0(project_dir,"out/medium_bins/mz_-0.013_-0.007_phosphotyrosine_containing_foreground.tsv"), sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)
# for background we only want phosphotyrosines but from across ALL bins
# first get all bin data together and only keep unique rows (as some peptidoforms that could have bi or trimodal distribution may be captured in multiple bins)
tyrosines_containing_background <- bind_rows(cleaned_postGMM_data) %>% distinct()
# filter down to only include phosphotyrosine-containing peptides
tyrosines_containing_background <- tyrosines_containing_background[grepl("Y2", tyrosines_containing_background$peptidoform_id), ]
# save
write.table(tyrosines_containing_background, file = paste0(project_dir,"out/medium_bins/phopshotyrosine_containing_background.tsv"),
sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_foreground_inSwissProt, file = "../out/medium_bins/phosphotyrosine_containing_foreground_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# also write the ones with no hit
tyrosines_containing_foreground_UNMATCHED <- tyrosines_containing_foreground[!tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
write.table(tyrosines_containing_foreground_UNMATCHED, file = "../out/medium_bins/phosphotyrosine_containing_foreground_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# first generate a list of lists with the background IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
background_id_list <- lapply(strsplit(tyrosines_containing_background$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)
# process each sublist in background_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the background_cleaned_IDs list to then add to our data frame
flattened_background_cleaned_IDs <- sapply(background_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_background$cleaned_protein_IDs <- flattened_background_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_background_inSwissProt <- tyrosines_containing_background[tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_background_inSwissProt, file = "../out/medium_bins/phosphotyrosine_containing_background_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# also write the ones with no hit
tyrosines_containing_background_UNMATCHED <- tyrosines_containing_background[!tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
write.table(tyrosines_containing_background_UNMATCHED, file = "../out/medium_bins/phosphotyrosine_containing_background_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
library(biomaRt)
library(devtools)
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
?useEnsembl
listEnsembl()
listEnsembl(mart = NULL, version = NULL,
GRCh = NULL, mirror = NULL, verbose = FALSE)
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
devtools::install_version("dbplyr", version = "2.3.4")
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
library(dplyr)
library(dbplyr)
library(dbplyr)
library(BiocFileCache)
invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE))
warnings()
library(tidyverse)
library(stringr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
# Get the corresponding Entrez IDs for all UniProt IDs that we can
Uniprot = getBM(
attributes=c('ensembl_gene_id','uniprotswissprot'),
mart = ensembl)
# 85 of our background IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
# subset to only include these who do
background <- tyrosines_containing_background_inSwissProt[tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]
# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(background$cleaned_protein_IDs, Uniprot$uniprotswissprot)
# Extract corresponding ENSEMBL Gene IDs
background_genes <- Uniprot$ensembl_gene_id[matched_indices]
# Remove NAs if any (in case some SwissProt IDs didn't have a match)
background_genes <- na.omit(background_genes)
# subset to only include these who do
foreground <- tyrosines_containing_foreground_inSwissProt[tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]
# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(foreground$cleaned_protein_IDs, Uniprot$uniprotswissprot)
# Extract corresponding ENSEMBL Gene IDs
foreground_genes <- Uniprot$ensembl_gene_id[matched_indices]
# Remove NAs if any (in case some SwissProt IDs didn't have a match)
foreground_genes <- na.omit(foreground_genes)
# 0 of our foreground IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
cluster_GO_MF <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
goplot(cluster_GO_MF)
GO_term_dataframe_MF
foreground_genes
background_genes
cluster_GO_MF <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.5)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
goplot(cluster_GO_MF)
View(GO_term_dataframe_MF)
cluster_GO_MF <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.5,
qvalueCutoff = 0.5)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
View(GO_term_dataframe_MF)
cluster_GO_MF <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 1)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
View(GO_term_dataframe_MF)
goplot(cluster_GO_MF)
goplot(cluster_GO_MF)
barplot(cluster_GO_MF)
barplot(cluster_GO_MF)
cluster_GO_MF <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.5,
qvalueCutoff = 1)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
goplot(cluster_GO_MF)
barplot(cluster_GO_MF)
goplot(cluster_GO_MF)
barplot(cluster_GO_MF)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
View(GO_term_dataframe_CC)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC)
barplot(cluster_GO_CC)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.5,
qvalueCutoff = 0.05)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.5)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
View(GO_term_dataframe_CC)
foreground_genes
background_genes
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 1)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
View(GO_term_dataframe_CC)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 0.05,
qvalueCutoff = 0.05)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
goplot(cluster_GO_BP)
barplot(cluster_GO_BP)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 1)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
View(GO_term_dataframe_BP)
# I might need entrez IDs, otherwise I get NULL
library(biomaRt)
library(ggplot2)
foreground_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
filters = 'ensembl_gene_id',
values = foreground_genes,
mart = ensembl)
background_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
filters = 'ensembl_gene_id',
values = background_genes,
mart = ensembl)
# make sure to convert to character too!
foreground_entrez_ids <- as.character(na.omit(foreground_entrez$entrezgene_id))
background_entrez_ids <- as.character(na.omit(background_entrez$entrezgene_id))
kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 0.5, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
dotplot(kegg_enrichment, showCategory = 10, font.size = 8) # returns only top 2
kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 1, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
# do dotplot manually
# extract df
KEGG_df <- kegg_enrichment@result
View(KEGG_df)
# filter down to just p<0.05
KEGG_Significant_Pathways <- KEGG_df[KEGG_df$pvalue <0.1,]
names(KEGG_Significant_Pathways)
KEGG_Significant_Pathways$GeneRatio <- sapply(strsplit(KEGG_Significant_Pathways$GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))
ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
geom_point(aes(size = Count, color = pvalue)) +
scale_color_gradient(low = "red", high = "blue") +
labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
theme_bw() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
plot.title = element_text(hjust = 0.5)
) +
ggtitle("KEGG Pathways with p<0.05")
ggtitle("KEGG Pathways with p<0.05")
ggsave("../out/medium_bins/KEGG_dotplot_bw_phosphotyrosinesonly.png", plot = last_plot(), width = 6, height = 4, dpi = 300)
ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
geom_point(aes(size = Count, color = pvalue)) +
scale_color_gradient(low = "red", high = "blue") +
labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
theme_bw() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
plot.title = element_text(hjust = 0.5)
) +
ggtitle("KEGG Pathways with p<0.05")
ggsave("../out/medium_bins/KEGG_dotplot_bw_phosphotyrosinesonly.png", plot = last_plot(), width = 6, height = 4, dpi = 300)
library(ReactomePA)
reactome_ORA <- enrichPathway(gene=foreground_entrez_ids,
universe=background_entrez_ids,
pvalueCutoff = 1, readable=TRUE)
#no hits at pcutoff 0.05
head(reactome_ORA)
