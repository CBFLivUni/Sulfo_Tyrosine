# Keep everything after "sp|" and before the second "|"
cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
# step 3 deal with gi|315259111|ref|NP_001186752.1| cases
cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
# looks for strings starting with gi and keeps
# all text after the first occurance of NP_ up until but excluding the first subsequent |
# # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID.
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
## to process a sublist of a list of lists where each sublist is a row cell of
# the protein IDs.
# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
# specify the extension unique to your calibrated files
extension = "postGMM"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)
```{r read_data, echo=FALSE}
For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)
```{r read_data, echo=FALSE}
# specify the extension unique to your calibrated files
extension = "postGMM"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
```{r read_data, echo=FALSE}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
```{r read_data, echo=FALSE}
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
#separate the name into pars splitting at _
parts <- unlist(strsplit(name, "_"))
# Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
lower <- round(as.numeric(parts[2]), 4)
upper <- round(as.numeric(parts[3]), 4)
# Storing the boundaries
# index = 1
lower_boundaries[length(lower_boundaries) + 1] <<- lower
upper_boundaries[length(upper_boundaries) + 1] <<- upper
# Reconstructing the cleaned name (and returning it)
return(paste0("mz_", lower, "_", upper))
}
clean_data <- function(data) {
for (i in 1:ncol(data)) {
cleaned_col <- lapply(data[, i], function(x) {
clean_string <- gsub("\\[|\\]|'", "", x)
if (i == 5) {
clean_string <- gsub(";", ",", clean_string)
}
elements <- unlist(strsplit(clean_string, ',\\s*'))
return(elements)
})
if (i == 2) {
data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
} else {
data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
}
}
return(data)
}
# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
# step one, deal with NX_ etries
# Remove "NX_" prefix and any the suffix following a dash
cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)
# step 2, deal with sp/ID/ cases
# Keep everything after "sp|" and before the second "|"
cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
# step 3 deal with gi|315259111|ref|NP_001186752.1| cases
cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
# looks for strings starting with gi and keeps
# all text after the first occurance of NP_ up until but excluding the first subsequent |
# # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID.
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
## to process a sublist of a list of lists where each sublist is a row cell of
# the protein IDs.
# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
gsub("postGMM_fitting_binrange", "mz", input_filenames)
View(postGMM_data)
ension unique to your calibrated files
ension unique to your calibrated files
# specify the extension unique to your calibrated files
extension = "postGMM"
library(tidyverse)
library(stringr)
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/02_medium bins/"
gc()
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/02_medium bins/"
gc()
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
#separate the name into pars splitting at _
parts <- unlist(strsplit(name, "_"))
# Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
lower <- round(as.numeric(parts[2]), 4)
upper <- round(as.numeric(parts[3]), 4)
# Storing the boundaries
# index = 1
lower_boundaries[length(lower_boundaries) + 1] <<- lower
upper_boundaries[length(upper_boundaries) + 1] <<- upper
# Reconstructing the cleaned name (and returning it)
return(paste0("mz_", lower, "_", upper))
}
clean_data <- function(data) {
for (i in 1:ncol(data)) {
cleaned_col <- lapply(data[, i], function(x) {
clean_string <- gsub("\\[|\\]|'", "", x)
if (i == 5) {
clean_string <- gsub(";", ",", clean_string)
}
elements <- unlist(strsplit(clean_string, ',\\s*'))
return(elements)
})
if (i == 2) {
data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
} else {
data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
}
}
return(data)
}
# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
# step one, deal with NX_ etries
# Remove "NX_" prefix and any the suffix following a dash
cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)
# step 2, deal with sp/ID/ cases
# Keep everything after "sp|" and before the second "|"
cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
# step 3 deal with gi|315259111|ref|NP_001186752.1| cases
cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
# looks for strings starting with gi and keeps
# all text after the first occurance of NP_ up until but excluding the first subsequent |
# # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID.
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
## to process a sublist of a list of lists where each sublist is a row cell of
# the protein IDs.
# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
# specify the extension unique to your calibrated files
extension = "postGMM"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
# create a data frame with one row for each bin
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names
# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries
# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df,
########## TYROSINE
tyrosine_containing_peptides_count = integer(length(postGMM_data)),
phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
tyrosine_containing_proportion = numeric(length(postGMM_data)),
phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
######### THREONINE
threonine_containing_peptides_count = integer(length(postGMM_data)),
phosphothreonine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
threonine_containing_proportion = numeric(length(postGMM_data)),
phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
######## SERINE
serine_containing_peptides_count = integer(length(postGMM_data)),
phosphoserine_containing_peptides_count = integer(length(postGMM_data)),
total_peptidoforms = integer(length(postGMM_data)),
serine_containing_proportion = numeric(length(postGMM_data)),
phosphoserine_containing_proportion = numeric(length(postGMM_data)))
# Iterate through each bin
for (i in seq_along(postGMM_data)) {
data <- postGMM_data[[i]]
results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
results$total_peptidoforms[i] <- nrow(data)
# Calculating proportions
results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
# Now for threonine
results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id))
# Calculating proportions
results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
## and for serine
results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id))
# Calculating proportions
results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
}
# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$phospho_to_total_tyrosine_ratio <- results$phosphotyrosine_containing_peptides_count /
results$tyrosine_containing_peptides_count
# Ratio of phospho-Threonine to total Threonine-containing peptides
results$phospho_to_total_threonine_ratio <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count
# Ratio of phospho-serine to total serine-containing peptides
results$phospho_to_total_serine_ratio <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count
Y_cont_med_bins_chi <- chisq.test(results$tyrosine_containing_peptides_count)
print(chi_squared_result)
print(Y_cont_med_bins_chi)
# Calculate total counts of tyrosine-containing peptides and total peptides
total_tyrosine_containing <- sum(df$tyrosine_containing_peptides_count)
# Calculate total counts of tyrosine-containing peptides and total peptides
total_tyrosine_containing <- sum(results$tyrosine_containing_peptides_count)
total_peptides <- sum(results$total_peptidoforms)
# Expected proportion of tyrosine-containing peptides
expected_proportion_tyrosine <- total_tyrosine_containing / total_peptides
# Calculate expected counts for each bin
expected_counts <- results$total_peptidoforms * expected_proportion_tyrosine
# Create a contingency table for the observed and expected counts
observed_counts <- results$tyrosine_containing_peptides_count
contingency_table <- rbind(observed_counts, expected_counts)
# Perform the Chi-Squared test
chi_squared_result <- chisq.test(contingency_table)
# Print the results
print(chi_squared_result)
View(contingency_table)
# Get the standardized residuals
std_residuals <- chi_squared_result$stdres
# Combine the bin IDs with their respective standardized residuals
bin_residuals <- data.frame(bin_ID = df$bin_ID, std_residuals)
# Combine the bin IDs with their respective standardized residuals
bin_residuals <- data.frame(bin_ID = results$bin_ID, std_residuals)
# Print the standardized residuals for each bin
print(bin_residuals)
# Optionally, you might want to visualize the residuals to better understand their distribution
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
xlab='Bin ID', ylab='Standardized Residuals',
main='Standardized Residuals per Bin')
View(bin_residuals)
# Calculate total counts of tyrosine-containing peptides and total peptides
total_tyrosine_containing <- sum(results$tyrosine_containing_peptides_count)
total_peptides <- sum(results$total_peptidoforms)
# Expected proportion of tyrosine-containing peptides
expected_proportion_tyrosine <- total_tyrosine_containing / total_peptides
# Calculate expected counts for each bin
expected_counts <- results$total_peptidoforms * expected_proportion_tyrosine
# Create a contingency table for the observed and expected counts
observed_counts <- results$tyrosine_containing_peptides_count
contingency_table <- cbind(observed_counts, expected_counts)
# Perform the Chi-Squared test
chi_squared_result <- chisq.test(contingency_table)
# Print the results
print(chi_squared_result)
# Get the standardized residuals
std_residuals <- chi_squared_result$stdres
# Combine the bin IDs with their respective standardized residuals
bin_residuals <- data.frame(bin_ID = results$bin_ID, std_residuals)
# Print the standardized residuals for each bin
print(bin_residuals)
# Optionally, you might want to visualize the residuals to better understand their distribution
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
xlab='Bin ID', ylab='Standardized Residuals',
main='Standardized Residuals per Bin')
bin_residuals
View(bin_residuals)
# Optionally, you might want to visualize the residuals to better understand their distribution
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
xlab='Bin ID', ylab='Standardized Residuals',
main='Standardized Residuals per Bin')
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
abline(h=0, col='red')
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b',
xlab='Bin ID', ylab='Standardized Residuals',
main='Standardized Residuals per Bin')
