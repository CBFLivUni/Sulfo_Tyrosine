# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID?
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
## to process a sublist of a list of lists where each sublist is a row cell of
# the protein IDs.
# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
#### subsetting swiss prot gene ids amnd returning uniprot ones for enrichment
extractEnsemblGeneIDs <- function(dataSet, uniprotMapping) {
# subset to only include IDs present in UniProt mapping
subsetData <- dataSet[dataSet$cleaned_protein_IDs %in% uniprotMapping$uniprotswissprot,]
# match SwissProt IDs in the UniProt data frame to get the position index
matchedIndices <- match(subsetData$cleaned_protein_IDs, uniprotMapping$uniprotswissprot)
# rxtract corresponding ENSEMBL Gene IDs
ensemblGeneIDs <- uniprotMapping$ensembl_gene_id[matchedIndices]
# remove NAs if any (in case some SwissProt IDs didn't have a match)
ensemblGeneIDs <- na.omit(ensemblGeneIDs)
return(ensemblGeneIDs)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
# specify the extension unique to your calibrated files
extension = "postGMM"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe
# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)
# Now, cleaned_names should have the format like 'mz_0.300-0.400'
# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()
# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))
names(postGMM_data) <- cleaned_names
# we need to clean the read in data as it contains python chaacters (e.g. [] for a list)
# rm(cleaned_postGMM_data, test)
gc()
cleaned_postGMM_data <- list()
for (i in 1:length(postGMM_data)) {
cleaned_postGMM_data[[i]] <- clean_data(postGMM_data[[i]])
print(i/length(postGMM_data))
}
names(cleaned_postGMM_data) <- names(postGMM_data)
# this is A DECOY bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_0.0175_0.0225"]]
names(cleaned_postGMM_data)
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
#                 file = paste0(project_dir,"out/DECOY", bin_name, "_tyrosine_containing_foreground.tsv"),
#                 sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)
#
#
#     # Append to the decoy bins list
#     DECOY_bins_list[[bin_name]] <- tyrosines_containing_bin
# }
#
# # for background we only want tyrosines but from across ALL bins, including bin of interest
# first get all bin data together and only keep unique rows (as some peptidoforms that could have bi or trimodal distribution may be captured in multiple bins)
tyrosines_containing_background <- bind_rows(cleaned_postGMM_data) %>% distinct()
# filter down to only include phosphotyrosine-containing peptides
tyrosines_containing_background <- tyrosines_containing_background[grepl("Y", tyrosines_containing_background$peptidoform_id), ]
# run cleaning to retain SwissProt entry only
# Split Swiss_Prot_Human$neXtProt and Swiss_Prot_Human$RefSeq into lists of IDs
# Apply the split_ids function I wrote; we will need these
neXtProt_list <- lapply(Swiss_Prot_Human$neXtProt, split_ids)
# run cleaning to retain SwissProt entry only
# Split Swiss_Prot_Human$neXtProt and Swiss_Prot_Human$RefSeq into lists of IDs
# Apply the split_ids function I wrote; we will need these
neXtProt_list <- lapply(Swiss_Prot_Human$neXtProt, split_ids)
RefSeq_list <- lapply(Swiss_Prot_Human$RefSeq, split_ids)
# run cleaning to retain SwissProt entry only
# Split Swiss_Prot_Human$neXtProt and Swiss_Prot_Human$RefSeq into lists of IDs
# Apply the split_ids function I wrote; we will need these
neXtProt_list <- lapply(Swiss_Prot_Human$neXtProt, split_ids)
RefSeq_list <- lapply(Swiss_Prot_Human$RefSeq, split_ids)
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# also write the ones with no hit
tyrosines_containing_foreground_UNMATCHED <- tyrosines_containing_foreground[!tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# first generate a list of lists with the background IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
background_id_list <- lapply(strsplit(tyrosines_containing_background$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)
# process each sublist in background_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# process each sublist in background_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# first generate a list of lists with the background IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
background_id_list <- lapply(strsplit(tyrosines_containing_background$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)
# process each sublist in background_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the background_cleaned_IDs list to then add to our data frame
flattened_background_cleaned_IDs <- sapply(background_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_background$cleaned_protein_IDs <- flattened_background_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_background_inSwissProt <- tyrosines_containing_background[tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# also write the ones with no hit
tyrosines_containing_background_UNMATCHED <- tyrosines_containing_background[!tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
library(clusterProfiler)
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
# Get the corresponding Entrez IDs for all UniProt IDs that we can
Uniprot = getBM(
attributes=c('ensembl_gene_id','uniprotswissprot'),
mart = ensembl)
# 84 of our background IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
# 0 of our foreground IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)
# convert swiss prot to ensembl gene ids and remove unmatched
background_genes <- extractEnsemblGeneIDs(tyrosines_containing_background_inSwissProt, Uniprot)
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
# convert swiss prot to ensembl gene ids and remove unmatched
background_genes <- extractEnsemblGeneIDs(tyrosines_containing_background_inSwissProt, Uniprot)
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
dotplot(cluster_GO_MF)
dotplot(cluster_GO_MF)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
dotplot(cluster_GO_CC)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff =  0.1)
goplot(cluster_GO_BP)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
GO_term_dataframe_BP
View(GO_term_dataframe_BP)
goplot(cluster_GO_CC)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
View(GO_term_dataframe_CC)
dotplot(cluster_GO_CC)
dotplot(cluster_GO_BP)
# this is A DECOY bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_0.0125_0.0175"]]
names(cleaned_postGMM_data)
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# also write the ones with no hit
tyrosines_containing_foreground_UNMATCHED <- tyrosines_containing_foreground[!tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# convert swiss prot to ensembl gene ids and remove unmatched
background_genes <- extractEnsemblGeneIDs(tyrosines_containing_background_inSwissProt, Uniprot)
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
dotplot(cluster_GO_MF)
gotplot(cluster_GO_MF)
########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
View(GO_term_dataframe_MF)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
dotplot(cluster_GO_CC)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff =  0.1)
dotplot(cluster_GO_BP)
# this is A DECOY bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_0.0075_0.0125"]]
names(cleaned_postGMM_data)
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
dotplot(cluster_GO_MF)
dotplot(cluster_GO_CC)
dotplot(cluster_GO_BP)
# this is the bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_-0.0125_-0.0075"]]
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1) # some leeway but not too much
dotplot(cluster_GO_BP, showCategory=10)
dotplot(cluster_GO_BP, showCategory=8)
cluster_GO_CC <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
dotchart(cluster_GO_BP)
dotplot(cluster_GO_BP)
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
dotplot(cluster_GO_MF)
dotplot(cluster_GO_CC)
# this is A DECOY bin of interest where we expect to find enrichment of sulfotyr
bin_of_interest <- cleaned_postGMM_data[["mz_-0.0175_-0.0125"]]
# for our foreground we only really want phosphotyrosine-containing peptides in
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a
# phosphotyrosine because some phosphogroups assigned to be positionally on a
# Threonine or Serine might actually be on a Tyrosine.
tyrosines_containing_foreground <- bin_of_interest[grepl("Y", bin_of_interest$peptidoform_id), ]
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
n
n
# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))
# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)
# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)
# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)
# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))
tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# For foreground dataset
foreground_genes <- extractEnsemblGeneIDs(tyrosines_containing_foreground_inSwissProt, Uniprot)
cluster_GO_MF <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
cluster_GO_CC <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.1)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene      = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff =  0.1)
dotplot(cluster_GO_BP)
dotplot(cluster_GO_CC)
dotplot(cluster_GO_MF)
