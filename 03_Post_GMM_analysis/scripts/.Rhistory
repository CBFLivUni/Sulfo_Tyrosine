keyType      = "ENSEMBL", #just to make sure
ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.073)
goplot(cluster_GO_MF)
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.202)
GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)
max(GO_term_dataframe_CC$qvalue)
GO_term_dataframe_CC <- GO_term_dataframe_CC[GO_term_dataframe_CC$pvalue < 0.05,]
max(GO_term_dataframe_CC$qvalue) #[1] 0.3776229
cluster_GO_CC <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff = 0.05)
goplot(cluster_GO_CC)
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff =  0.252)
foreground_genes
GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)
max(GO_term_dataframe_BP$qvalue)
# here more stringent otherwise too many hits
GO_term_dataframe_BP <- GO_term_dataframe_BP[GO_term_dataframe_BP$pvalue < 0.005,]
max(GO_term_dataframe_BP$qvalue) #  0.252
######### now for biological processes
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
universe     = background_genes,
OrgDb        = org.Hs.eg.db,  # human annotation
keyType      = "ENSEMBL", #just to make sure
ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
pAdjustMethod = "BH", # Benjamini-Hochberg
pvalueCutoff = 1,
qvalueCutoff =  0.07)
# Add similarity matrix to the enrichment result
cluster_GO_tree_MF <- pairwise_termsim(cluster_GO_MF, method = "Wang", semData = GO_similarity_MF)
cluster_GO_tree_CC <- pairwise_termsim(cluster_GO_CC, method = "Wang", semData = GO_similarity_CC)
cluster_GO_tree_BP <- pairwise_termsim(cluster_GO_BP, method = "Wang", semData = GO_similarity_BP)
foreground_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
filters = 'ensembl_gene_id',
values = foreground_genes,
mart = ensembl)
# make sure to convert to character too!
foreground_entrez_ids <- as.character(na.omit(foreground_entrez$entrezgene_id))
kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 1, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
dotplot(kegg_enrichment, showCategory = 10, font.size = 8) # returns only top 2
# do dotplot manually
# extract df
KEGG_df <- kegg_enrichment@result
# filter down to just p<0.05
KEGG_Significant_Pathways <- KEGG_df[KEGG_df$pvalue <0.05,]
names(KEGG_Significant_Pathways)
KEGG_Significant_Pathways$GeneRatio <- sapply(strsplit(KEGG_Significant_Pathways$GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))
ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
geom_point(aes(size = Count, color = pvalue)) +
scale_color_gradient(low = "red", high = "blue") +
labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
theme_bw() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
plot.title = element_text(hjust = 0.5)
) +
ggtitle("KEGG Pathways with p<0.05 but not p.adj")
# Start PDF device
pdf("../out/EnrichmentPlots_DECOY_minus2_abithacky.pdf", width=8.27, height=11.69)
# "Title PAGE"
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
text(0.5, 0.5, "GO Molecular Function, DECOY_minus2", cex = 2.5)
goplot(cluster_GO_MF)
barplot(cluster_GO_MF, showCategory = 30)
treeplot(cluster_GO_tree_MF)
# "Title PAGE"
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
text(0.5, 0.5, "GO Biological Process, DECOY_minus2", cex = 2.5)
goplot(cluster_GO_BP)
barplot(cluster_GO_BP, showCategory = 30)
treeplot(cluster_GO_tree_BP)
# "Title PAGE"
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
text(0.5, 0.5, "GO Cellular Component, DECOY_minus2", cex = 2.5)
goplot(cluster_GO_CC)
barplot(cluster_GO_CC, showCategory = 30)
treeplot(cluster_GO_tree_CC)
# "Title PAGE"
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
text(0.5, 0.5, "KEGG, DECOY_minus2_mz_-0.0225_-0.0175", cex = 2.5)
ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
geom_point(aes(size = Count, color = pvalue)) +
scale_color_gradient(low = "red", high = "blue") +
labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
theme_bw() +
theme(
legend.position = "right",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
plot.title = element_text(hjust = 0.5)
) +
ggtitle("KEGG Pathways with p<0.05 but not p.adj")
dev.off()
library(tidyverse)
library(stringr)
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/"
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/in/"
# specify the extension unique to your calibrated files
extension = "tyrosine_containing"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
print(i/length(input_filenames)*100)
}
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]], sep =  "\t")
print(i/length(input_filenames)*100)
}
library(tidyverse)
library(stringr)
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/in/"
gc()
# specify the extension unique to your calibrated files
extension = "tyrosine_containing"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]], sep =  "\t")
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
View(postGMM_data)
##### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
#separate the name into pars splitting at _
parts <- unlist(strsplit(name, "_"))
# Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
lower <- round(as.numeric(parts[2]), 4)
upper <- round(as.numeric(parts[3]), 4)
# Storing the boundaries
# index = 1
lower_boundaries[length(lower_boundaries) + 1] <<- lower
upper_boundaries[length(upper_boundaries) + 1] <<- upper
# Reconstructing the cleaned name (and returning it)
return(paste0("mz_", lower, "_", upper))
}
clean_data <- function(data) {
for (i in 1:ncol(data)) {
cleaned_col <- lapply(data[, i], function(x) {
clean_string <- gsub("\\[|\\]|'", "", x)
if (i == 5) {
clean_string <- gsub(";", ",", clean_string)
}
elements <- unlist(strsplit(clean_string, ',\\s*'))
return(elements)
})
if (i == 2) {
data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
} else {
data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
}
}
return(data)
}
# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
# step one, deal with NX_ etries
# Remove "NX_" prefix and any the suffix following a dash
cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)
# step 2, deal with sp/ID/ cases
# Keep everything after "sp|" and before the second "|"
cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
# step 3 deal with gi|315259111|ref|NP_001186752.1| cases
cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
# looks for strings starting with gi and keeps
# all text after the first occurance of NP_ up until but excluding the first subsequent |
# # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID?
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
#### subsetting swiss prot gene ids amnd returning uniprot ones for enrichment
extractEnsemblGeneIDs <- function(dataSet, uniprotMapping) {
# subset to only include IDs present in UniProt mapping
subsetData <- dataSet[dataSet$cleaned_protein_IDs %in% uniprotMapping$uniprotswissprot,]
# match SwissProt IDs in the UniProt data frame to get the position index
matchedIndices <- match(subsetData$cleaned_protein_IDs, uniprotMapping$uniprotswissprot)
# rxtract corresponding ENSEMBL Gene IDs
ensemblGeneIDs <- uniprotMapping$ensembl_gene_id[matchedIndices]
# remove NAs if any (in case some SwissProt IDs didn't have a match)
ensemblGeneIDs <- na.omit(ensemblGeneIDs)
return(ensemblGeneIDs)
}
input_filenames
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/in/"
gc()
##### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
#separate the name into pars splitting at _
parts <- unlist(strsplit(name, "_"))
# Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
lower <- round(as.numeric(parts[2]), 4)
upper <- round(as.numeric(parts[3]), 4)
# Storing the boundaries
# index = 1
lower_boundaries[length(lower_boundaries) + 1] <<- lower
upper_boundaries[length(upper_boundaries) + 1] <<- upper
# Reconstructing the cleaned name (and returning it)
return(paste0("mz_", lower, "_", upper))
}
clean_data <- function(data) {
for (i in 1:ncol(data)) {
cleaned_col <- lapply(data[, i], function(x) {
clean_string <- gsub("\\[|\\]|'", "", x)
if (i == 5) {
clean_string <- gsub(";", ",", clean_string)
}
elements <- unlist(strsplit(clean_string, ',\\s*'))
return(elements)
})
if (i == 2) {
data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
} else {
data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
}
}
return(data)
}
# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
# step one, deal with NX_ etries
# Remove "NX_" prefix and any the suffix following a dash
cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)
# step 2, deal with sp/ID/ cases
# Keep everything after "sp|" and before the second "|"
cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
# step 3 deal with gi|315259111|ref|NP_001186752.1| cases
cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
# looks for strings starting with gi and keeps
# all text after the first occurance of NP_ up until but excluding the first subsequent |
# # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
# cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
# ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID?
# after cleaning,keep only the unique IDs at this stage
cleaned_IDs <- unique(cleaned_IDs)
return(cleaned_IDs)
}
## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
# First, try splitting with "; "
split_result <- strsplit(string, "; ")
# If the length of any split_result is 1, it means there was no "; " to split on
# In this case, try splitting with just ";"
if (any(sapply(split_result, length) == 1)) {
split_result <- strsplit(string, ";")
}
return(split_result)
}
## to process a sublist of a list of lists where each sublist is a row cell of
# the protein IDs.
# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is
process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
# Check for hits in Swiss_Prot_Human$Entry
entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
if (length(entry_hits) > 0) {
return(entry_hits)
}
# Check for hits in Swiss_Prot_Human$neXtProt
for (id in sublist) {
if (any(sapply(neXtProt_list, function(x) id %in% x))) {
matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# Check for hits in Swiss_Prot_Human$RefSeq
for (id in sublist) {
if (any(sapply(RefSeq_list, function(x) id %in% x))) {
matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
return(Swiss_Prot_Human$Entry[matching_row])
}
}
# If no matches, return the original sublist
return(sublist)
}
#### subsetting swiss prot gene ids amnd returning uniprot ones for enrichment
extractEnsemblGeneIDs <- function(dataSet, uniprotMapping) {
# subset to only include IDs present in UniProt mapping
subsetData <- dataSet[dataSet$cleaned_protein_IDs %in% uniprotMapping$uniprotswissprot,]
# match SwissProt IDs in the UniProt data frame to get the position index
matchedIndices <- match(subsetData$cleaned_protein_IDs, uniprotMapping$uniprotswissprot)
# rxtract corresponding ENSEMBL Gene IDs
ensemblGeneIDs <- uniprotMapping$ensembl_gene_id[matchedIndices]
# remove NAs if any (in case some SwissProt IDs didn't have a match)
ensemblGeneIDs <- na.omit(ensemblGeneIDs)
return(ensemblGeneIDs)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
#
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
#
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
#
# # Remove the objects
# rm(list = objects_to_remove)
#
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
#
# rm("all_objects", "data_objects")
# specify the extension unique to your calibrated files
extension = "inSwissProt"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]], sep =  "\t")
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
input_filenames
# Cleaning the names
cleaned_names <- gsub("tyrosine_containing_", "", input_filenames)
cleaned_names
cleaned_names <- gsub("_inSwissProt.tsv", "", cleaned_names, fixed = TRUE)
cleaned_names
names(postGMM_data) <- cleaned_names
View(postGMM_data)
names(postGMM_data)
DECOY_minus1 <- postGMM_data[[1]]
DECOY_minus2 <- postGMM_data[[2]]
foregrround <- postGMM_data[[6]]
DECOY2 <- postGMM_data[[4]]
DECOY3 <- postGMM_data[[5]]
merged_of_interest <- rbind(DECOY_minus1, DECOY_minus2, foregrround)
# Find unique IDs
unique_DECOY_minus1 <- setdiff(DECOY_minus1$peptidoform_ID, c(DECOY_minus2$peptidoform_ID, foreground$peptidoform_ID))
DECOY_minus1 <- postGMM_data[[1]]
DECOY_minus2 <- postGMM_data[[2]]
foreground <- postGMM_data[[6]]
DECOY2 <- postGMM_data[[4]]
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/05_LookIntoSpecificProteins/in/"
gc()
# specify the extension unique to your calibrated files
extension = "inSwissProt"
# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)
# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)
# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list.
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
print(bin_data_files[[i]])
postGMM_data[[i]] <- read.csv(bin_data_files[[i]], sep =  "\t")
print(i/length(input_filenames)*100)
}
# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe
# Cleaning the names
cleaned_names <- gsub("tyrosine_containing_", "", input_filenames)
cleaned_names <- gsub("_inSwissProt.tsv", "", cleaned_names, fixed = TRUE)
names(postGMM_data) <- cleaned_names
## save tpo objects.e asier to work with:
## bin of interest and decoy bins next to it.
DECOY_minus1 <- postGMM_data[[1]]
DECOY_minus2 <- postGMM_data[[2]]
foreground <- postGMM_data[[6]]
# decoy bins around 0.01 mz
DECOY1 <- postGMM_data[[3]]
DECOY2 <- postGMM_data[[4]]
DECOY3 <- postGMM_data[[5]]
merged_of_interest <- rbind(DECOY_minus1, DECOY_minus2, foreground)
View(merged_of_interest)
# Find unique IDs
unique_DECOY_minus1 <- setdiff(DECOY_minus1$peptidoform_ID, c(DECOY_minus2$peptidoform_ID, foreground$peptidoform_ID))
unique_DECOY_minus2 <- setdiff(DECOY_minus2$peptidoform_ID, c(DECOY_minus1$peptidoform_ID, foreground$peptidoform_ID))
unique_foreground <- setdiff(foreground$peptidoform_ID, c(DECOY_minus1$peptidoform_ID, DECOY_minus2$peptidoform_ID))
unique_DECOY_minus2
unique_DECOY_minus1
# Find unique IDs
unique_DECOY_minus1 <- setdiff(DECOY_minus1$peptidoform_ID,  foreground$peptidoform_ID)
unique_DECOY_minus1
unique_DECOY_minus2 <- setdiff(DECOY_minus2$peptidoform_ID, foreground$peptidoform_ID)
unique_DECOY_minus2
unique_foreground <- setdiff(foreground$peptidoform_ID, c(DECOY_minus1$peptidoform_ID, DECOY_minus2$peptidoform_ID))
unique_foreground
# Find unique IDs
nonunique_DECOY_minus1 <- DECOY_minus1$peptidoform_ID %in%  foreground$peptidoform_ID
nonunique_DECOY_minus1
DECOY_minus1$peptidoform_ID
View(DECOY_minus1)
# Find unique IDs
unique_DECOY_minus1 <- setdoff(DECOY_minus1$peptidoform_id,  foreground$peptidoform_id)
# Find unique IDs
unique_DECOY_minus1 <- setdiff(DECOY_minus1$peptidoform_id,  foreground$peptidoform_id)
unique_DECOY_minus1
unique_DECOY_minus2
unique_DECOY_minus2 <- setdiff(DECOY_minus2$peptidoform_id, foreground$peptidoform_id)
unique_DECOY_minus2
merged_of_interest <- rbind(DECOY_minus1, DECOY_minus2, foreground) %>% unique()
e
unique_foreground <- setdiff(foreground$peptidoform_id, c(DECOY_minus1$peptidoform_id, DECOY_minus2$peptidoform_id))
unique_foreground
write.csv(merged_of_interest, file = "../out/potential_sulfo_peptidoforms.csv", row.names = FALSE)
merged_plus_side <-  rbind(DECOY1, DECOY2, DECOY3) %>% unique()
unique_DECOY2 <- setdiff(DECOY2$peptidoform_id,  DECOY1$peptidoform_id)
unique_DECOY3 <- setdiff(DECOY3$peptidoform_id, DECOY1$peptidoform_id)
unique_DECOY1 <- setdiff(DECOY1$peptidoform_id, c(DECOY2$peptidoform_id, DECOY3$peptidoform_id))
# 166 not in DECOY1 bin
unique_DECOY3 <- setdiff(DECOY3$peptidoform_id, c(DECOY2$peptidoform_id,DECOY1$peptidoform_id))
