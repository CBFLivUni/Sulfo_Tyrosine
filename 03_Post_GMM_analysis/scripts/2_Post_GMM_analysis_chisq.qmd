---
title: "Post_GMM_Analysis"
format: pdf
editor: visual
---

```{r libraries}
library(tidyverse)
library(stringr) 
library(ggplot2)
library(ggrepel)
library(dplyr)
```

```{r functions}
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
  
  #separate the name into pars splitting at _
  parts <- unlist(strsplit(name, "_"))
 
  # Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
  lower <- round(as.numeric(parts[2]), 4)
  upper <- round(as.numeric(parts[3]), 4)

  # Storing the boundaries
  # index = 1
  lower_boundaries[length(lower_boundaries) + 1] <<- lower
  upper_boundaries[length(upper_boundaries) + 1] <<- upper

  # Reconstructing the cleaned name (and returning it)
  return(paste0("mz_", lower, "_", upper))
}

# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
# 
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
# 
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
# 
# # Remove the objects
# rm(list = objects_to_remove)
# 
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
# 
# rm("all_objects", "data_objects")


```

## Get proportion of tyrosine-containing peptides

For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)

```{r read_data, echo=FALSE}
# specify the extension unique to your calibrated files
extension = "postGMM"
wd <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/"
# get all files of interest
bin_data_files <- list.files(wd, pattern = extension, full.names = TRUE, recursive = TRUE)

# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)

# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list. 
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
  print(bin_data_files[[i]])
  postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
  print(i/length(input_filenames)*100)
}
```

```{r clean_names}
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe

# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_threshold_30_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)

# Now, cleaned_names should have the format like 'mz_0.300-0.400' 

# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()


# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))

names(postGMM_data) <- cleaned_names

```

```{r get_bin_results}
# create a data frame with one row for each bin 
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names

# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries

# for each bin, look at the corresponding data in post_GMM_data, and count:
# 1) the overall number of Tyrosine-containing peptides (one or more Y present in peptidoform ID coplumn)

# 2) the number of phosphotyrosine-containing peptides (Y243 present)

# 3) the total number of peptidoforms

# 4) calculate the proportion of tyrosine containing and proportion of phophotyrosine containing peptides in each bin

## NB: also do the same for Serine and Threonine to compare 

# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df, 
                      ########## TYROSINE 
                      tyrosine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)), 
                      total_peptidoforms = integer(length(postGMM_data)), 
                      tyrosine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
                      ######### THREONINE
                      threonine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphothreonine_containing_peptides_count = integer(length(postGMM_data)), 
                      #total_peptidoforms = integer(length(postGMM_data)), 
                      threonine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
                      ######## SERINE
                      serine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphoserine_containing_peptides_count = integer(length(postGMM_data)), 
                      #total_peptidoforms = integer(length(postGMM_data)), 
                      serine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphoserine_containing_proportion = numeric(length(postGMM_data)))

# test_df <- data.frame(peptidoform_id = c("TTT", "Y", "TYTY", "TY_Y243"))
# data <- test_df

# Iterate through each bin
for (i in seq_along(postGMM_data)) {
  data <- postGMM_data[[i]]

  results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
  results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
  results$total_peptidoforms[i] <- nrow(data)

  # Calculating proportions
  results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
  # Now for threonine
  
  results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
  results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id)) 
  

  # Calculating proportions
  results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
  
  ## and for serine
  
  results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
  results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id)) 
  

  # Calculating proportions
  results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
}

# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$pY_containing_fraction_of_Ycontaining <- results$phosphotyrosine_containing_peptides_count / 
  results$tyrosine_containing_peptides_count

# Ratio of phospho-Threonine to total Threonine-containing peptides
results$pT_containing_fraction_of_Tcontaining <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count

# Ratio of phospho-serine to total serine-containing peptides
results$pS_containing_fraction_of_Scontaining <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count



write.csv(results, file = "../out/PTM_proportions_results_by_bin_newdat.csv", row.names = FALSE)


## reorder column names
new_order <- c("bin_ID",
               "lower_boundary",
               "upper_boundary",
               "total_peptidoforms",
               "threonine_containing_peptides_count",
               "serine_containing_peptides_count",
               "tyrosine_containing_peptides_count",
               "phosphothreonine_containing_peptides_count",
               "phosphoserine_containing_peptides_count",
               "phosphotyrosine_containing_peptides_count",
               "threonine_containing_proportion",
               "serine_containing_proportion",
               "tyrosine_containing_proportion",
               "phosphothreonine_containing_proportion",
               "phosphoserine_containing_proportion",
               "phosphotyrosine_containing_proportion",
               "pT_containing_fraction_of_Tcontaining",
               "pS_containing_fraction_of_Scontaining",
               "pY_containing_fraction_of_Ycontaining"
               )

results <- results[, new_order]
names(results)

# round the columns that contain proportions to 4 decimals for the plots - all except first 10
results[, 10:ncol(results)] <- lapply(results[, 10:ncol(results)], round, 4)
# check
head(results)

# also order by m/z 
results <- results[order(results$lower_boundary), ]

# Then, plot with highlighting
# Create a new column 'highlight' based on conditions
results$highlight <- ifelse(results$bin_ID == "mz_-0.0125_-0.0075", "Bin of Interest",
                            ifelse(results$bin_ID %in% c("mz_0.0075_0.0125", "mz_0.0125_0.0175", "mz_0.0175_0.0225"), "DECOY", "Normal"))


# Assign color-blind friendly colors
color_blind_friendly_colors <- c("Bin of Interest" = "#E69F00", # orange
                                 "DECOY" = "#56B4E9", # sky blue
                                 "Normal" = "grey") # yellow

```

```{r plotting_tests}
###################### barplots   ################
# order by bin m/z when plotting!!

ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = tyrosine_containing_peptides_count)) +
  geom_bar(stat = "identity", aes(fill = highlight)) +
  scale_fill_manual(values = color_blind_friendly_colors) +
  geom_text(aes(label = tyrosine_containing_peptides_count, color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
  scale_color_manual(values = color_blind_friendly_colors) + # Match text color to bar color
  theme_minimal() +
  labs(x = "Bin ID", y = "Count", title = "Tyrosine-Containing Peptides by Bin") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(fill = guide_legend(title = "Category"), color = FALSE) # Hide the color legend

#basic
ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = tyrosine_containing_peptides_count)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = tyrosine_containing_peptides_count), vjust = -0.5, size = 3) + # Add counts above bars
  theme_minimal() +
  labs(x = "Bin ID", y = "Count", title = "Tyrosine-Containing Peptides by Bin") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


#with gradient

ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = tyrosine_containing_peptides_count)) +
  geom_bar(stat = "identity", aes(fill = tyrosine_containing_peptides_count)) +  # Use count for color gradient
  scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Gradient from light to dark blue
  geom_text(aes(label = tyrosine_containing_peptides_count), vjust = -0.5, size = 3) +
  theme_minimal() +
  labs(x = "Bin ID", y = "Count", title = "Tyrosine-Containing Peptides by Bin") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r barplots}
# below was ran in a separate script: plot_saving.R
# Define columns to plot (all except the first three and the highlight colour column)
columns_to_plot <- names(results)[4:ncol(results)-1]

# Start PDF device
pdf("../out/BarPlots_byBin_15pc_individual.pdf", width = 11, height = 8.5)

# Loop through each column to create and save the plot
for (col in columns_to_plot) {
  p <- ggplot(results, aes(x = reorder(bin_ID, lower_boundary), y = get(col))) +
    geom_bar(stat = "identity", aes(fill = highlight)) +
    scale_fill_manual(values = color_blind_friendly_colors) +
    geom_text(aes(label = get(col), color = highlight), vjust = -0.5, size = 3, fontface = "bold") +
    scale_color_manual(values = color_blind_friendly_colors) +
    theme_minimal() +
    labs(x = "Bin ID", y = col, title = paste(col, "by Bin")) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    guides(fill = guide_legend(title = "Category"), color = FALSE)
  
  print(p) # Print the plot to the PDF device
}

# Close the PDF device
dev.off()


```

```{r scatterplots}
#################### scatter plts ########
names(results)
######### serine #########
#
# Create the scatter plot using geom_text_repel for labels
p <- ggplot(results, aes(x = serine_containing_proportion, 
                         y = phosphoserine_containing_proportion)) +
  geom_point(aes(color = highlight), size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_text_repel(aes(label = bin_ID), size = 2.5, box.padding = 0.35, point.padding = 0.5) +
  scale_color_manual(values = color_blind_friendly_colors) +
  theme_bw() +
  labs(x = "Serine-Containing Peptides Proportion", y = "Phosphoserine-Containing Peptides Proportion", title = "Scatter Plot of Phosphoserine vs. Serine-Containing Peptides Proportion") +
  theme(legend.title = element_blank())

# Display the plot
print(p)


# Save the plot using ggsave
ggsave(filename = "../out/ScatterPlot_Phosphoserine_vs_Serine.pdf", 
       plot = p, 
       path = "../out", width = 8, height = 6, dpi = 300)



############# threonine ############### 
# Threonine Scatter Plot
p_threonine <- ggplot(results, aes(x = threonine_containing_proportion, y = phosphothreonine_containing_proportion)) +
  geom_point(aes(color = highlight), size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_text_repel(aes(label = bin_ID), size = 2.5, box.padding = 0.35, point.padding = 0.5) +
  scale_color_manual(values = color_blind_friendly_colors) +
  theme_bw() +
  labs(x = "Threonine-Containing Peptides Proportion", y = "Phosphothreonine-Containing Peptides Proportion", 
       title = "Scatter Plot of Phosphothreonine vs. Threonine-Containing Peptides Proportion") +
  theme(legend.title = element_blank())

p_threonine

# Save the Threonine Scatter Plot
ggsave(filename = "../out/ScatterPlot_Phosphothreonine_vs_Threonine.pdf", 
       plot = p_threonine, 
       width = 8, height = 6, dpi = 300)




############ tyrosine ##############

# Tyrosine Scatter Plot
p_tyrosine <- ggplot(results, aes(x = tyrosine_containing_proportion, y = phosphotyrosine_containing_proportion)) +
  geom_point(aes(color = highlight), size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_text_repel(aes(label = bin_ID), size = 2.5, box.padding = 0.35, point.padding = 0.5) +
  scale_color_manual(values = color_blind_friendly_colors) +
  theme_bw() +
  labs(x = "Tyrosine-Containing Peptides Proportion", y = "Phosphotyrosine-Containing Peptides Proportion", 
       title = "Scatter Plot of Phosphotyrosine vs. Tyrosine-Containing Peptides Proportion") +
  theme(legend.title = element_blank())

# Save the Tyrosine Scatter Plot
ggsave(filename = "../out/ScatterPlot_Phosphotyrosine_vs_Tyrosine.pdf", 
       plot = p_tyrosine, 
       width = 8, height = 6, dpi = 300)

########## m/z on x ############

# in plot_saving script

```

```{r chi_squared_tests_functionbuilding}
# 
# 
# head(chi_results)
# 
# 
# # observed counts for tyrosine-containing peptides in each bin
# observed_counts <- chi_results$tyrosine_containing_peptides_count
# 
# # expected counts for tyrosine-containing peptides in each bin
# expected_counts <- chi_results$expected_Y_counts
# 
# # Perform the Chi-squared test with simulation to get expected counts, if not already done
# chi_squared_test <- chisq.test(observed_counts, p = expected_counts / sum(expected_counts), simulate.p.value = TRUE)
# 
# # Calculate standardized residuals
# standardized_residuals <- chi_squared_test$stdres
# 
# # Create a bin ID vector corresponding to the residuals
# bin_IDs <- chi_results$bin_ID
# 
# # Plotting the standardized residuals
# residuals_data <- data.frame(bin_ID = bin_IDs, Residuals = standardized_residuals)
# 
# # Merge residuals_data with chi_results to include m/z boundaries
# residuals_data <- residuals_data %>%
#   left_join(chi_results %>% select(bin_ID, lower_boundary, upper_boundary), by = c("bin_ID" = "bin_ID"))
# 
# 
# chip <- ggplot(residuals_data, aes(x = reorder(bin_ID, lower_boundary), y = Residuals)) +
#   geom_point(size = 3) +
#   geom_hline(yintercept = c(-2, 2), linetype = "dashed", color = "red") + # Typical thresholds for significance
#   theme_minimal() +
#   labs(title = "Standardized Residuals from Chi-squared Test",
#        x = "Bin",
#        y = "Standardized Residual") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# # 
# # # turn above code into a function
# 
# # Define the function to perform the Chi-squared test and plot residuals
# plot_chi_squared_residuals <- function(data, observed_col_name, expected_col_name, pdf_path) {
#   # Perform the Chi-squared test with simulation to get expected counts
#   observed_counts <- data[[observed_col_name]]
#   expected_counts <- data[[expected_col_name]]
#   chi_squared_test <- chisq.test(observed_counts, p = expected_counts / sum(expected_counts), simulate.p.value = TRUE)
# 
#   # Calculate standardized residuals
#   standardized_residuals <- chi_squared_test$stdres
# 
#   # Create a dataframe for plotting
#   residuals_data <- data.frame(bin_ID = data$bin_ID, Residuals = standardized_residuals)
# 
#   # Merge residuals_data with the original data to include m/z boundaries
#   residuals_data <- residuals_data %>%
#     left_join(data %>% select(bin_ID, lower_boundary), by = "bin_ID") %>%
#     arrange(lower_boundary) # Order by lower boundary for plotting
# 
#   # Plotting the standardized residuals
#   plot_title <- paste0("Standardized Residuals from Chi-squared Test of ", observed_col_name)
#   p <- ggplot(residuals_data, aes(x = reorder(bin_ID, lower_boundary), y = Residuals)) +
#     geom_point(size = 3) +
#     geom_hline(yintercept = c(-2, 2), linetype = "dashed", color = "red") + # Thresholds for significance
#     theme_minimal() +
#     labs(title = plot_title,
#          x = "Bin (Ordered by Lower m/z Boundary)",
#          y = "Standardized Residual") +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))
#   print(p)
#   # # Save the plot as a PDF
#   # ggsave(paste0(pdf_path, "ChiSquared_Residuals_plot_", observed_col_name), plot = p, width = 11, height = 8.5)
# }


# ### modify function to suit use of 2 data frames
# Modify the function to accept two dataframes and their corresponding columns
plot_chi_squared_residuals <- function(observed_df, expected_df, observed_col, expected_col, pdf_device) {
  # Extract the counts from the dataframes
  observed_counts <- observed_df[[observed_col]]
  expected_counts <- expected_df[[expected_col]]
  
  # Perform the Chi-squared test
  chi_squared_test <- chisq.test(observed_counts, p = expected_counts / sum(expected_counts), simulate.p.value = TRUE)
  
  # Calculate standardized residuals
  standardized_residuals <- chi_squared_test$stdres
  
  # Create a dataframe for plotting
  residuals_data <- data.frame(bin_ID = observed_df$bin_ID, Residuals = standardized_residuals)
  
  # Merge residuals_data with the original data to include m/z boundaries
  residuals_data <- residuals_data %>%
    left_join(observed_df %>% select(bin_ID, lower_boundary), by = "bin_ID") %>%
    arrange(lower_boundary) # Order by lower boundary for plotting
  
  # Plotting the standardized residuals
  plot_title <- paste0("Standardized Residuals from Chi-squared Test of ", observed_col)
  p <- ggplot(residuals_data, aes(x = reorder(bin_ID, lower_boundary), y = Residuals)) +
    geom_point(size = 3) +
    geom_hline(yintercept = c(-2, 2), linetype = "dashed", color = "red") + # Thresholds for significance
    theme_minimal() +
    labs(title = plot_title,
         x = "Bin (Ordered by Lower m/z Boundary)",
         y = "Standardized Residual") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Print the plot on the PDF device
  print(p)
}


# 
# 
# 
# 
# 
# 
# 
# # Example approach for phosphotyrosine-containing vs. non-phosphotyrosine-containing
# # Calculate non-phosphotyrosine counts
# chi_results$non_tyrosine_containing_peptides_count <- chi_results$total_peptidoforms - chi_results$tyrosine_containing_peptides_count
# 
# # Constructing a contingency table (example for phosphotyrosine vs. non-phosphotyrosine)
# # Assuming 'chi_results' is already sorted by 'bin_ID' or another meaningful order
# contingency_table <- with(chi_results, table(bin_ID, c("tyrosine", "non_tyrosine"), 
#                                              list(tyrosine_containing_peptides_count, non_tyrosine_containing_peptides_count)))
# 
# # Perform Chi-squared test
# chi_squared_test <- chisq.test(contingency_table)
# 
# # View results
# print(chi_squared_test)
# # # Calculate total counts of tyrosine-containing peptides and total peptides
# # total_tyrosine_containing <- sum(results$tyrosine_containing_peptides_count)
# # total_peptides <- sum(results$total_peptidoforms)
# # 
# # # Expected proportion of tyrosine-containing peptides
# # expected_proportion_tyrosine <- total_tyrosine_containing / total_peptides
# # 
# # # Calculate expected counts for each bin
# # expected_counts <- results$total_peptidoforms * expected_proportion_tyrosine
# # 
# # # Create a contingency table for the observed and expected counts
# # observed_counts <- results$tyrosine_containing_peptides_count
# # contingency_table <- rbind(observed_counts, expected_counts)
# # 
# # # Perform the Chi-Squared test
# # chi_squared_result <- chisq.test(contingency_table)
# # 
# # # Print the results
# # print(chi_squared_result)
# # 
# # 
# # # Get the standardized residuals
# # std_residuals <- chi_squared_result$stdres
# # 
# # # Combine the bin IDs with their respective standardized residuals
# # bin_residuals <- data.frame(bin_ID = results$bin_ID, std_residuals)
# # 
# # # Print the standardized residuals for each bin
# # print(bin_residuals)
# # 
# # # Optionally, you might want to visualize the residuals to better understand their distribution
# # plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b', 
# #      xlab='Bin ID', ylab='Standardized Residuals', 
# #      main='Standardized Residuals per Bin')
# # abline(h=0, col='red')

```

```{r chi_Squared_resultsgeneration_oncounts}
## need a tleas 5 observations per variable for each bin; we know this is not the case for the two bins at the lowest m/z; too few peptidoforms have been recorded for these bins so we will remove them for the chi-squared tests

# sort by mz lower boundary and remove two bins with too few observations
sorted_results <- results[order(results$lower_boundary), ]
chi_results <- sorted_results[-c(1:2), ]

# for chis squared tests we would need to get some expected proportions for the null hypothesis that all bins have the same proportions accross 
# combine all data frames into one and retain only unique peptidoform rows
combined_df <- bind_rows(postGMM_data) %>% 
  distinct()

# NB this includes the bins we removed above, but since they contribute a tiny fraction of all peptidoforms, some of which not unique, it should be OK.

total_peptidoforms <- nrow(combined_df)
Y_containing_total <- sum(grepl("Y", combined_df$peptidoform_id))
T_containing_total <- sum(grepl("T", combined_df$peptidoform_id))
S_containing_total <- sum(grepl("S", combined_df$peptidoform_id))

pY_containing_total <- sum(grepl("Y243", combined_df$peptidoform_id))
pT_containing_total <- sum(grepl("T181", combined_df$peptidoform_id))
pS_containing_total <- sum(grepl("S167", combined_df$peptidoform_id))


# calculate overall proportions
prop_Y = Y_containing_total / total_peptidoforms
prop_T = T_containing_total / total_peptidoforms
prop_S = S_containing_total / total_peptidoforms

prop_pY = pY_containing_total / total_peptidoforms
prop_pT = pT_containing_total / total_peptidoforms
prop_pS = pS_containing_total / total_peptidoforms

# calculate expected counts for each bin
expected_counts_for_chi <- data.frame(
  bin_ID = chi_results$bin_ID,
  lower_boundary = chi_results$lower_boundary,
  total_peptidoforms = chi_results$total_peptidoforms,
  expected_Y_counts = chi_results$total_peptidoforms * prop_Y,
  expected_T_counts = chi_results$total_peptidoforms * prop_T,
  expected_S_counts = chi_results$total_peptidoforms * prop_S,
  expected_pY_counts = chi_results$total_peptidoforms * prop_pY,
  expected_pT_counts = chi_results$total_peptidoforms * prop_pT,
  expected_pS_counts = chi_results$total_peptidoforms * prop_pS
)


# crate my data frame of observed results in the same order
observed_counts_for_chi <- data.frame(
  bin_ID = chi_results$bin_ID,
  lower_boundary = chi_results$lower_boundary,
  total_peptidoforms = chi_results$total_peptidoforms,
  observed_Y_counts = chi_results$tyrosine_containing_peptides_count,
  observed_T_counts = chi_results$threonine_containing_peptides_count,
  observed_S_counts = chi_results$serine_containing_peptides_count,
  observed_pY_counts = chi_results$phosphotyrosine_containing_peptides_count,
  observed_pT_counts = chi_results$phosphothreonine_containing_peptides_count,
  observed_pS_counts = chi_results$phosphoserine_containing_peptides_count
)
################################### we can perform chi squared test for each column of # interest; below code was run in save_plots.R script
pdf("../out/ChiSquared_residuals.pdf", width = 11, height = 8.5)

# Loop over the columns and generate the plots
for (i in 5:ncol(observed_counts_for_chi)) {
  observed_col <- names(observed_counts_for_chi)[i]
  expected_col <- names(expected_counts_for_chi)[i]
  
  plot_chi_squared_residuals(observed_counts_for_chi, expected_counts_for_chi, observed_col, expected_col, pdf_device = NULL)
}

# Close the PDF device
dev.off()

```

```{r chi_squared_onproportions}
## kind of hacky?? 
# calculate expected "counts" for each bin by multiplying by 100
expected_proportions_for_chi <- data.frame(
  bin_ID = chi_results$bin_ID,
  lower_boundary = chi_results$lower_boundary,
  total_peptidoforms = chi_results$total_peptidoforms,
  expected_Y_proportions = round(prop_Y * 100),
  expected_T_proportions = round(prop_T * 100),
  expected_S_proportions = round(prop_S * 100),
  expected_pY_proportions = round(prop_pY * 100),
  expected_pT_proportions = round(prop_pT * 100),
  expected_pS_proportions = round(prop_pS * 100),
  expected_pY_fraction_of_Y = round(prop_pY/prop_Y * 100),
  expected_pT_fraction_of_T = round(prop_pT/prop_T * 100),
  expected_pS_fraction_of_S = round(prop_pS/prop_S * 100)
)



# crate my data frame of observed results in the same order
observed_proportions_for_chi <- data.frame(
  bin_ID = chi_results$bin_ID,
  lower_boundary = chi_results$lower_boundary,
  total_peptidoforms = chi_results$total_peptidoforms,
  observed_Y_proportions = round(chi_results$tyrosine_containing_proportion * 100),
  observed_T_proportions = round(chi_results$threonine_containing_proportion * 100),
  observed_S_proportions = round(chi_results$serine_containing_proportion * 100),
  observed_pY_proportions = round(chi_results$phosphotyrosine_containing_proportion * 100),
  observed_pT_proportions = round(chi_results$phosphothreonine_containing_proportion * 100),
  observed_pS_proportions = round(chi_results$phosphoserine_containing_proportion * 100),
  observed_pY_fraction_of_Y = round(chi_results$pY_containing_fraction_of_Ycontaining * 100),
  observed_pT_fraction_of_T = round(chi_results$pT_containing_fraction_of_Tcontaining * 100),
  observed_pS_fraction_of_S = round(chi_results$pS_containing_fraction_of_Scontaining * 100)
)


pdf("../out/FishersExactTest_pvalues_2.pdf", width = 11, height = 8.5)

# List of peptide types to test
peptide_types <- c("Y", "T", "S", "pY", "pT", "pS")

# Loop over the peptide types and generate the plots
for (peptide in peptide_types) {
  observed_col <- paste("observed", peptide, "counts", sep = "_")
  expected_col <- paste("expected", peptide, "counts", sep = "_")
  
  plot_fishers_exact_test(observed_counts_for_fisher, expected_counts_for_fisher, peptide, pdf_device = NULL)
}

# Close the PDF device
dev.off()

```

```{r fishersexacttest}
# fishers test should work with small number fo samples so no need to exclude bins
fisher_results <- sorted_results

# again construct two dataframes as before, easier to copy and paste and replace
# calculate expected counts for each bin
expected_counts_for_fisher <- data.frame(
  bin_ID = fisher_results$bin_ID,
  lower_boundary = fisher_results$lower_boundary,
  total_peptidoforms = fisher_results$total_peptidoforms,
  expected_Y_counts = fisher_results$total_peptidoforms * prop_Y,
  expected_T_counts = fisher_results$total_peptidoforms * prop_T,
  expected_S_counts = fisher_results$total_peptidoforms * prop_S,
  expected_pY_counts = fisher_results$total_peptidoforms * prop_pY,
  expected_pT_counts = fisher_results$total_peptidoforms * prop_pT,
  expected_pS_counts = fisher_results$total_peptidoforms * prop_pS
)


# crate my data frame of observed results in the same order
observed_counts_for_fisher <- data.frame(
  bin_ID = fisher_results$bin_ID,
  lower_boundary = fisher_results$lower_boundary,
  total_peptidoforms = fisher_results$total_peptidoforms,
  observed_Y_counts = fisher_results$tyrosine_containing_peptides_count,
  observed_T_counts = fisher_results$threonine_containing_peptides_count,
  observed_S_counts = fisher_results$serine_containing_peptides_count,
  observed_pY_counts = fisher_results$phosphotyrosine_containing_peptides_count,
  observed_pT_counts = fisher_results$phosphothreonine_containing_peptides_count,
  observed_pS_counts = fisher_results$phosphoserine_containing_peptides_count
)

# Define the function to perform Fisher's Exact test and plot p-values
plot_fishers_exact_test <- function(observed_df, expected_df, peptide_type, pdf_device) {
  # Extract the counts for Fisher's test
  observed_counts <- round(observed_df[[paste("observed", peptide_type, "counts", sep = "_")]]) # Ensure integer counts
  total_counts <- round(observed_df$total_peptidoforms) # Ensure integer counts
  expected_counts <- round(expected_df[[paste("expected", peptide_type, "counts", sep = "_")]]) # Ensure integer counts
  
  # Construct a 2x2 contingency table for each bin
  # Row 1: Observed counts vs. rest of the observed counts for the peptide type
  # Row 2: Expected counts vs. rest of the expected counts for the peptide type
  contingency_table <- matrix(c(observed_counts, total_counts - observed_counts,
                                expected_counts, sum(total_counts) - expected_counts),
                              nrow = 2)
  
  # Perform Fisher's Exact Test with increased workspace
  fishers_test <- fishers_test <- fisher.test(contingency_table, simulate.p.value = TRUE, B = 10000)
 # Increase workspace as needed
  
  # Store the p-value
  p_value <- fishers_test$p.value
  
  # Plotting the p-values
  plot_title <- paste0("Fisher's Exact Test p-values of ", peptide_type)
  p <- ggplot(data.frame(bin_ID = observed_df$bin_ID, P_Value = p_value), aes(x = bin_ID, y = P_Value)) +
    geom_point(size = 3) +
    geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") + # Significance threshold
    theme_minimal() +
    labs(title = plot_title,
         x = "Bin",
         y = "p-value") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Print the plot on the PDF device
  print(p)
}

# Open a PDF device to save all plots into a single PDF
pdf("../out/FishersExactTest_pvalues.pdf", width = 11, height = 8.5)

# List of peptide types to test
peptide_types <- c("Y", "T", "S", "pY", "pT", "pS")

# Loop over the peptide types and generate the plots
for (peptide in peptide_types) {
  observed_col <- paste("observed", peptide, "counts", sep = "_")
  expected_col <- paste("expected", peptide, "counts", sep = "_")
  
  plot_fishers_exact_test(observed_counts_for_fisher, expected_counts_for_fisher, peptide, pdf_device = NULL)
}

# Close the PDF device
dev.off()




```

```{r protein_ID_enrichment_results}
### run enrichment analysis using cluster profiler
# read in all human proteins for data filtering
Swiss_Prot_Human <- read.csv(file = "C:/Users/jtzve/Genomics Dropbox/Jordan Tzvetkov/0_Projects/Sulfotyrosine Project/data/SwissProt_Human_proteins.tsv"
, sep = "\t")

head(Swiss_Prot_Human)
Swiss_Prot_Human[1,1]
# make sure no bias in inclusion criteria
# phosphotyrosine-containing peptidoforms - grab all associated protein IDs across all bins as a background? 
# vs foreground just the ones in the correct bin
# if indeed sulfo, we would get an enrichment in cytokines, secreted proteins, membrane proteins, or similar

# if random there should be no significant hits

# try also running for a different bin with a similar number of hits as the expected sulfo bin. 
class(Swiss_Prot_Human)






# 5) bin matches to libraries of transmembrane and secreted proteins: 

# 5_1) how many of all peptides have IDs in any of these categories for all bins? 
# THIS is probably not very usefun info actually...

# 5_2) how many Tyrosine-containng are trans-memeb and how many are secreted (as proportion?) 

# 5_3) how many phospho-tryosine containing ones are secreted/transmemb? 

#### could our data suggest sulfation of other amino acids at all? 




```
