---
title: "Post_GMM_Analysis"
format: pdf
editor: visual
---

```{r libraries}
library(tidyverse)
library(stringr) 

```

```{r directories}
project_dir = "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/"
data_dir <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/02_medium bins/"
gc()
```

```{r functions}
###### Function to get clean filenames, and round and extract bin boundaries ######
clean_round_extract <- function(name, index) {
  
  #separate the name into pars splitting at _
  parts <- unlist(strsplit(name, "_"))
 
  # Rounding the numbers to the fourth decimal place; lower bin boundary is the 2nd part, upper is the 3rd part
  lower <- round(as.numeric(parts[2]), 4)
  upper <- round(as.numeric(parts[3]), 4)

  # Storing the boundaries
  # index = 1
  lower_boundaries[length(lower_boundaries) + 1] <<- lower
  upper_boundaries[length(upper_boundaries) + 1] <<- upper

  # Reconstructing the cleaned name (and returning it)
  return(paste0("mz_", lower, "_", upper))
}


clean_data <- function(data) {
  for (i in 1:ncol(data)) {
    cleaned_col <- lapply(data[, i], function(x) {
      clean_string <- gsub("\\[|\\]|'", "", x)
      if (i == 5) {
        clean_string <- gsub(";", ",", clean_string)
      }
      elements <- unlist(strsplit(clean_string, ',\\s*'))
      return(elements)
    })

    if (i == 2) {
      data[, i] <- sapply(cleaned_col, function(x) paste(x, collapse = ", "))
    } else {
      data[, i] <- sapply(cleaned_col, function(x) paste(unique(x), collapse = ", "))
    }
  }
  return(data)
}

# function to clean the protein IDs in the Input data
ProteinIDCleaningFunction <- function(IDs) {
  
  # step one, deal with NX_ etries
  # Remove "NX_" prefix and any the suffix following a dash
  cleaned_IDs <- gsub("(^NX_[^-]+)-.*", "\\1", IDs)


  
  # step 2, deal with sp/ID/ cases
  # Keep everything after "sp|" and before the second "|"
  cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
  
  
  # step 3 deal with gi|315259111|ref|NP_001186752.1| cases 
  
  cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
  # looks for strings starting with gi and keeps 
  # all text after the first occurance of NP_ up until but excluding the first subsequent |
  
  
  # # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
  # cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
  # ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID. 
  # after cleaning,keep only the unique IDs at this stage
  cleaned_IDs <- unique(cleaned_IDs)
  
 return(cleaned_IDs)
}

## for getting next prot and Ref seq IDs from the SwissProt library
split_ids <- function(string) {
  # First, try splitting with "; "
  split_result <- strsplit(string, "; ")
  # If the length of any split_result is 1, it means there was no "; " to split on
  # In this case, try splitting with just ";"
  if (any(sapply(split_result, length) == 1)) {
    split_result <- strsplit(string, ";")
  }
  return(split_result)
}

## to process a sublist of a list of lists where each sublist is a row cell of 
# the protein IDs.

# for each sublist of IDs:
#
# 1) check if any of the IDs have a hit in Swiss_Prot_Human$Entry
# if yes replace that sublist with only the IDs with a hit (unlikely to be multiple)
# 2) if not check if any of the IDs have a hit in Swiss_Prot_Human$neXtProt
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# 3) if not, check if any of the IDs have a hit in Swiss_Prot_Human$RefSeq
# if yes retrieve the Swiss_Prot_Human$Entry for that row of Siwss_Prot_Human, then retain that Entry ID and replace the sublist with it
# if not keep the sublist as it is


process_sublist <- function(sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list) {
  # Check for hits in Swiss_Prot_Human$Entry
  entry_hits <- sublist[sublist %in% Swiss_Prot_Human$Entry]
  if (length(entry_hits) > 0) {
    return(entry_hits)
  }


  # Check for hits in Swiss_Prot_Human$neXtProt
  for (id in sublist) {
    if (any(sapply(neXtProt_list, function(x) id %in% x))) {
      matching_row <- which(sapply(neXtProt_list, function(x) id %in% x))
      return(Swiss_Prot_Human$Entry[matching_row])
    }
  }

  # Check for hits in Swiss_Prot_Human$RefSeq
  for (id in sublist) {
    if (any(sapply(RefSeq_list, function(x) id %in% x))) {
      matching_row <- which(sapply(RefSeq_list, function(x) id %in% x))
      return(Swiss_Prot_Human$Entry[matching_row])
    }
  }

  # If no matches, return the original sublist
  return(sublist)
}
# TODO: turn beow into a function to keep my environment tidy?
# # List of all objects in the environment
# all_objects <- ls()
# 
# # List of objects to keep (replace these with your actual data object names)
# data_objects <- c("postGMM_data")
# 
# # Objects to remove
# objects_to_remove <- setdiff(all_objects, data_objects)
# 
# # Remove the objects
# rm(list = objects_to_remove)
# 
# # Clear objects_to_remove to clean up
# rm(objects_to_remove)
# 
# rm("all_objects", "data_objects")


```

## Get proportion of tyrosine-containing peptides

For each m/z bin that we have collected data from, we want to see what proportion of the peptides selected via our filtering contain a phospho-tyrosine (which could potentially be a sulfo-tyorsine)

```{r read_data, echo=FALSE}
# specify the extension unique to your calibrated files
extension = "postGMM"

# get all files of interest
bin_data_files <- list.files(data_dir, pattern = extension, full.names = TRUE, recursive = TRUE)

# and get file path (not reltive!)
input_filenames <- basename(bin_data_files)

# read in all data one by one into an empty list, setting each data frame as a
# new elemnt of the list. 
postGMM_data <- list()
print("reading in data")
for (i in 1:length(bin_data_files)) {
  print(bin_data_files[[i]])
  postGMM_data[[i]] <- read.csv(bin_data_files[[i]])
  print(i/length(input_filenames)*100)
}

# read in all human proteins for data filtering - from Swiss Prot
Swiis_Prot_data_file <- "C:/Users/jtzve/Desktop/Sufo_Tyrosine/03_Post_GMM_analysis/data/SwissProtLibrary_2024_01_17.tsv"
Swiss_Prot_Human <- read.csv(file = Swiis_Prot_data_file, sep = "\t")
```

```{r clean_names}
# clean the names - remove .csv, round the ranges, leave just the range and put mz before it
# reatin information about bin ID == clean names, lower boundary, upper boundary to then put in a dataframe

# Cleaning the names
cleaned_names <- gsub("postGMM_fitting_binrange", "mz", input_filenames)
cleaned_names <- gsub(".csv", "", cleaned_names, fixed = TRUE)

# Now, cleaned_names should have the format like 'mz_0.300-0.400' 

# Initialize empty vectors to store upper and lower boundaries
lower_boundaries <- numeric()
upper_boundaries <- numeric()


# Applying the function to each name and storing the results
cleaned_names <- sapply(cleaned_names, clean_round_extract, seq_along(cleaned_names))

names(postGMM_data) <- cleaned_names

```

```{r get_bin_results}
# create a data frame with one row for each bin 
# rm(bin_proportions_df)
bin_proportions_df <- as.data.frame(matrix(nrow = length(postGMM_data), ncol = 0))
bin_proportions_df$bin_ID <- cleaned_names

# extract bin limits from the bin ID. round the values because they are a bit weird
bin_proportions_df$lower_boundary <- lower_boundaries
bin_proportions_df$upper_boundary <- upper_boundaries

# for each bin, look at the corresponding data in post_GMM_data, and count:
# 1) the overall number of Tyrosine-containing peptides (one or more Y present in peptidoform ID coplumn)

# 2) the number of phosphotyrosine-containing peptides (Y243 present)

# 3) the total number of peptidoforms

# 4) calculate the proportion of tyrosine containing and proportion of phophotyrosine containing peptides in each bin

## NB: also do the same for Serine and Threonine to compare 

# Initialise a data frame to store the results
results <- data.frame(bin_proportions_df, 
                      ########## TYROSINE 
                      tyrosine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphotyrosine_containing_peptides_count = integer(length(postGMM_data)), 
                      total_peptidoforms = integer(length(postGMM_data)), 
                      tyrosine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphotyrosine_containing_proportion = numeric(length(postGMM_data)),
                      ######### THREONINE
                      threonine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphothreonine_containing_peptides_count = integer(length(postGMM_data)), 
                      total_peptidoforms = integer(length(postGMM_data)), 
                      threonine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphothreonine_containing_proportion = numeric(length(postGMM_data)),
                      ######## SERINE
                      serine_containing_peptides_count = integer(length(postGMM_data)), 
                      phosphoserine_containing_peptides_count = integer(length(postGMM_data)), 
                      total_peptidoforms = integer(length(postGMM_data)), 
                      serine_containing_proportion = numeric(length(postGMM_data)), 
                      phosphoserine_containing_proportion = numeric(length(postGMM_data)))

# test_df <- data.frame(peptidoform_id = c("TTT", "Y", "TYTY", "TY_Y243"))
# data <- test_df

# Iterate through each bin
for (i in seq_along(postGMM_data)) {
  data <- postGMM_data[[i]]

  results$tyrosine_containing_peptides_count[i] <- sum(grepl("Y", data$peptidoform_id))
  results$phosphotyrosine_containing_peptides_count[i] <- sum(grepl("Y243", data$peptidoform_id))
  results$total_peptidoforms[i] <- nrow(data)

  # Calculating proportions
  results$tyrosine_containing_proportion[i] <- results$tyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphotyrosine_containing_proportion[i] <- results$phosphotyrosine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
  # Now for threonine
  
  results$threonine_containing_peptides_count[i] <- sum(grepl("T", data$peptidoform_id))
  results$phosphothreonine_containing_peptides_count[i] <- sum(grepl("T181", data$peptidoform_id)) 
  

  # Calculating proportions
  results$threonine_containing_proportion[i] <- results$threonine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphothreonine_containing_proportion[i] <- results$phosphothreonine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
  
  ## and for serine
  
  results$serine_containing_peptides_count[i] <- sum(grepl("S", data$peptidoform_id))
  results$phosphoserine_containing_peptides_count[i] <- sum(grepl("S167", data$peptidoform_id)) 
  

  # Calculating proportions
  results$serine_containing_proportion[i] <- results$serine_containing_peptides_count[i] / results$total_peptidoforms[i]
  results$phosphoserine_containing_proportion[i] <- results$phosphoserine_containing_peptides_count[i] / results$total_peptidoforms[i]
  
}

# might be interesting to look at what fraction of tyrosine-containing are 'phosphorylated'
results$phospho_to_total_tyrosine_ratio <- results$phosphotyrosine_containing_peptides_count / 
  results$tyrosine_containing_peptides_count

# Ratio of phospho-Threonine to total Threonine-containing peptides
results$phospho_to_total_threonine_ratio <- results$phosphothreonine_containing_peptides_count / results$threonine_containing_peptides_count

# Ratio of phospho-serine to total serine-containing peptides
results$phospho_to_total_serine_ratio <- results$phosphoserine_containing_peptides_count / results$serine_containing_peptides_count



write.csv(results, file = "../out/01_Sulfotyrosine_Proportions_By_Bin/PTM_proportions_results_by_bin.csv", row.names = FALSE)



```

```{r plots_chisq}
# Calculate total counts of tyrosine-containing peptides and total peptides
total_tyrosine_containing <- sum(results$tyrosine_containing_peptides_count)
total_peptides <- sum(results$total_peptidoforms)

# Expected proportion of tyrosine-containing peptides
expected_proportion_tyrosine <- total_tyrosine_containing / total_peptides

# Calculate expected counts for each bin
expected_counts <- results$total_peptidoforms * expected_proportion_tyrosine

# Create a contingency table for the observed and expected counts
observed_counts <- results$tyrosine_containing_peptides_count
contingency_table <- cbind(observed_counts, expected_counts)

# Perform the Chi-Squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the results
print(chi_squared_result)



# Get the standardized residuals
std_residuals <- chi_squared_result$stdres

# Combine the bin IDs with their respective standardized residuals
bin_residuals <- data.frame(bin_ID = results$bin_ID, std_residuals)

# Print the standardized residuals for each bin
print(bin_residuals)

# Optionally, you might want to visualize the residuals to better understand their distribution
plot(bin_residuals$bin_ID, bin_residuals$std_residuals, type='b', 
     xlab='Bin ID', ylab='Standardized Residuals', 
     main='Standardized Residuals per Bin')
abline(h=0, col='red')

```

## Data Cleaning for enrichment analysis using cluster profiler

```{r data_preclean}
# we need to clean the read in data as it contains python chaacters (e.g. [] for a list)
# rm(cleaned_postGMM_data, test)
gc()
cleaned_postGMM_data <- list()
for (i in 1:length(postGMM_data)) {
  
  cleaned_postGMM_data[[i]] <- clean_data(postGMM_data[[i]])
  print(i/length(postGMM_data))
  
}

names(cleaned_postGMM_data) <- names(postGMM_data)

```

```{r Prefiltering_of_PhosphoTyrosine_containing_only}

bin_of_interest <- cleaned_postGMM_data[["mz_-0.013_-0.007"]]

# for our foreground we only really want phosphotyrosine-containing peptides in 
# the bin of interest; reflect that in the background too!
## NB: PTM assignment might not be 100% correct and we want to actually include
# all tyrosine-containing peptidoforms, not just these assigned to have a 
# phosphotyrosine because some phosphogroups assigned to be positionally on a 
# Threonine or Serine might actually be on a Tyrosine. 
tyrosines_containing_foreground <- bin_of_interest[grepl("Y2", bin_of_interest$peptidoform_id), ]
# Save as a TSV file
write.table(tyrosines_containing_foreground, file = paste0(project_dir,"out/medium_bins/mz_-0.013_-0.007_phosphotyrosine_containing_foreground.tsv"), sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)


# for background we only want phosphotyrosines but from across ALL bins
# first get all bin data together and only keep unique rows (as some peptidoforms that could have bi or trimodal distribution may be captured in multiple bins)
tyrosines_containing_background <- bind_rows(cleaned_postGMM_data) %>% distinct()

# filter down to only include phosphotyrosine-containing peptides
tyrosines_containing_background <- tyrosines_containing_background[grepl("Y2", tyrosines_containing_background$peptidoform_id), ]

# save 
write.table(tyrosines_containing_background, file = paste0(project_dir,"out/medium_bins/phopshotyrosine_containing_background.tsv"), 
            sep = "\t", row.names =  FALSE, col.names = TRUE, quote = FALSE)


```

<!-- # foreground_proteins_with_SwissProt_ID <- foreground_proteins[foreground_proteins %in% SwissProt_Protein_IDs] -->

<!-- #  -->

<!-- # ## currently returns 0 protein IDs, so we need some further cleaning, lets investigate -->

<!-- # foreground_proteins[1:10] -->

<!-- # > foreground_proteins[1:10] -->

<!-- #  [1] "NX_P98172-1"                                               -->

<!-- #  [2] "NX_Q9P2Q2-1, NP_001305265.1"                               -->

<!-- #  [3] "NX_Q9Y4K1-1, A0A0J9YWL0"                                   -->

<!-- #  [4] "NX_P05129-1, NX_P05129-2"                                  -->

<!-- #  [5] "NX_Q13263-1, B2R8R5"                                       -->

<!-- #  [6] "sp|Q9H1K1|ISCU_HUMAN, NX_Q9H1K1-1, B3KQ30"                 -->

<!-- #  [7] "B4DSL6, NX_Q9NQW6-1_UNMAPPED"                              -->

<!-- #  [8] "NX_Q92538-1"                                               -->

<!-- #  [9] "NX_Q15032-3, B4DLH6, NX_Q15032-4, A0A804HIA8, NX_Q15032-1" -->

<!-- # [10] "NX_Q9Y2D9-1, A8K9F2, sp|Q9Y2D9|ZN652_HUMAN"  -->

<!-- # firstly, for some peptidoforms we have more than one protein hit -->

<!-- # secondly, by testing what is actually in our SwissProt entries, it seems -->

<!-- # like only proteins starting with NX_ are present, but the NX_ needs to be -->

<!-- # stripped, as does any - and number.  -->

<!-- # also, proteins starting with sp/ should eb included, but the entry -->

<!-- # is only within the / /; the last bit is the entry.name from swiss prot.  -->

<!-- # for proteins with no underscores, this is uniprotID; some of these will not have swiss prot IDs -->

<!-- #example: row 10 - NX_Q9Y2D9-1, A8K9F2, sp|Q9Y2D9|ZN652_HUMAN these 3 are all -->

<!-- # the same protein (A8K9F2 is a uniprot ID of a different protein that shares  -->

<!-- # high levels of similarity with Q9Y2D9, or Homo sapiens zinc finger protein 652 (ZNF652) -->

<!-- # finally, protein IDs starting with NP_ refer to NCBI Reference Sequence -->

<!-- #example: row 2 - NX_Q9P2Q2-1, NP_001305265.1 - both are the same FERM domain-containing protein 4A encoded by FRMD4A -->

<!-- #NB: these are just 4 of the cases we need to consider, they may be more across the dataset! -->

<!--  # another 2 spotted subsequently:  -->

<!-- # e.g. gi|315259111|ref|NP_001186752.1| -> keep the NP_number -->

<!-- # e.g. "CONTRIB_KimS1_NPLOC4"  -> we want NPLOC4 -->

```{r protein_ID_cleaning_by_bin}
#### DO NOT RUN THIS! THIS IS FOR THE WHOLE BIN NOT JUST PHOSPHOTYROSINE
# 
# foreground_proteins <- bin_of_interest$protein
# alt_foreground_proteins <- bin_of_interest$alt_protein
# 
# # run some checks
# # "A1L0S7" %in% SwissProt_Protein_IDs
# # "A1L0S7" %in% foreground_id_list
# 
# # Swiss_Prot_Human[Swiss_Prot_Human$Entry == "Q9Y2D9", ]
# 
# # 1) convert to list of lists to handle cases where peptidoform has multiple IDs
# # NB: this is only if we want to keep positional information, but I think we 
# # should be ok working with just one very long vector or list of all IDs within 
# # the bin as we're not running any significance tests prior to the 
# # cluster profiler analysis, but doing it this way just to be safe
# 
# foreground_id_list <- lapply(strsplit(foreground_proteins, ", "), function(x) unlist(strsplit(x, ", ")))
# 
# 
# clean_foreground_ID_list  <- lapply(foreground_id_list, function(IDs) {
#   
#   # step one, deal with NX_ etries
#   # Remove "NX_" prefix and any the suffix following a dash
#   cleaned_IDs <- gsub("^NX_|-.*", "", IDs)
#   
#   # step 2, deal with sp/ID/ cases
#   # Keep everything after "sp|" and before the second "|"
#   cleaned_IDs <- gsub(".*sp\\|([^|]+)\\|.*", "\\1", cleaned_IDs)
#   
#   
#   # step 3 deal with gi|315259111|ref|NP_001186752.1| cases 
#   
#   cleaned_IDs <- gsub(".*gi\\|[^|]+\\|ref\\|(NP_[^|]+).*", "\\1", cleaned_IDs)
#   # looks for strings starting with gi and keeps 
#   # all text after the first occurance of NP_ up until but excluding the first subsequent |
#   
#   
#   # # Step 4: Handle cases starting with "CONTRIB" and keep everything after the last underscore "_"
#   # cleaned_IDs <- gsub("^CONTRIB_([^_]+)_.*", "\\1", cleaned_IDs)
#   # ### NB: These are gene names and not UniProt Entry IDs, so we actually want to do that step later and convert from gene name to UniProt ID. 
#   # after cleaning,keep only the unique IDs at this stage
#   cleaned_IDs <- unique(cleaned_IDs)
#   
#  return(cleaned_IDs)
# })
# 
# # convert to a list of all IDs to see which ones are in the SwissProt entries
# all_cleaned_IDs <- unique(unlist(clean_foreground_ID_list))
# 
# proteins_inSwissProt <- all_cleaned_IDs[all_cleaned_IDs%in% SwissProt_Protein_IDs]
# notinSwissProt <- all_cleaned_IDs[!all_cleaned_IDs%in% SwissProt_Protein_IDs]
# 
# notinSwissProt[1:20]
# 
# 
# # Split notinSwissProt into two groups: starting with NP_ (NCBI Reference Sequence) 
# # and others - likely uniprot IDs not part of SwissProt
# NCBI_RefSeqs <- notinSwissProt[grepl("^NP_", notinSwissProt)]
# notinSwissProt_others <- notinSwissProt[!grepl("^NP_", notinSwissProt)]
# 
# # Specify the file paths for each TSV file
# file_path_NCBI_RefSeqs <- "NCBI_RefSeqs.tsv"
# file_path_notinSwissProt_others <- "Unmatched_Others.tsv"
# 
# # Save NCBI_RefSeqs as a TSV file
# write.table(NCBI_RefSeqs, file = file_path_NCBI_RefSeqs, sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# # Save notinSwissProt_others as a TSV file
# write.table(notinSwissProt_others, file = file_path_notinSwissProt_others, sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# 
# # Use grep to find strings containing any of the specified special characters
# # these won't be uniprot IDs; rest are likely uniprot IDs
# 
# notUniProtIDs <- notinSwissProt_others[grep("_", notinSwissProt_others)]
# 
# UniProtIDs <- notinSwissProt_others[!(notinSwissProt_others %in% notUniProtIDs)]
# 
# 
# 
# write.table(notUniProtIDs, file = "remaining_exceptions.tsv", sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# 
# write.table(UniProtIDs, file = "UniProt_ButNotSwissProt_IDs_foreground.tsv", sep = "\t", row.names =  FALSE, col.names = FALSE, quote = FALSE)
# 
# # notinSwissProt_others_clean <- gsub("^CONTRIB_([^_]+)_.*", "\\1", notinSwissProt_others)
# 



```

```{r proteinID_foreground}
# run cleaning to retain SwissProt entry only
# Split Swiss_Prot_Human$neXtProt and Swiss_Prot_Human$RefSeq into lists of IDs
  # Apply the split_ids function I wrote; we will need these 
  neXtProt_list <- lapply(Swiss_Prot_Human$neXtProt, split_ids)
  RefSeq_list <- lapply(Swiss_Prot_Human$RefSeq, split_ids)


# first generate a list of lists with the foreground IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
foreground_id_list <- lapply(strsplit(tyrosines_containing_foreground$protein, ", "), function(x) unlist(strsplit(x, ", ")))

# clean them up to be able to match bakc to SwissProt library
clean_foreground_ID_list  <- lapply(foreground_id_list, ProteinIDCleaningFunction)

# keep only unique IDs for each row (sublist)
foreground_cleaned_IDs <- lapply(clean_foreground_ID_list, unique)

# process each sublist in foreground_cleaned_IDs to return the SwissProt Entry 
# if there is one, if not retain prevous ID(s)
foreground_cleaned_IDs <- lapply(foreground_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)


# Flatten the foreground_cleaned_IDs list to then add to our data frame
flattened_foreground_cleaned_IDs <- sapply(foreground_cleaned_IDs, function(x) paste(x, collapse = ","))

tyrosines_containing_foreground$cleaned_protein_IDs <- flattened_foreground_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_foreground_inSwissProt <- tyrosines_containing_foreground[tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_foreground_inSwissProt, file = "../out/medium_bins/phosphotyrosine_containing_foreground_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# also write the ones with no hit
tyrosines_containing_foreground_UNMATCHED <- tyrosines_containing_foreground[!tyrosines_containing_foreground$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]


write.table(tyrosines_containing_foreground_UNMATCHED, file = "../out/medium_bins/phosphotyrosine_containing_foreground_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)



```

```{r proteinID_background}

# first generate a list of lists with the background IDs
# the list is the protein IDs column, with each sublist representinc a row cell split at the ',' separator between different IDs
background_id_list <- lapply(strsplit(tyrosines_containing_background$protein, ", "), function(x) unlist(strsplit(x, ", ")))

# clean them up to be able to match bakc to SwissProt library
clean_background_ID_list  <- lapply(background_id_list, ProteinIDCleaningFunction)

# keep only unique IDs for each row (sublist)
background_cleaned_IDs <- lapply(clean_background_ID_list, unique)

# process each sublist in background_cleaned_IDs to return the SwissProt Entry 
# if there is one, if not retain prevous ID(s)
background_cleaned_IDs <- lapply(background_cleaned_IDs, process_sublist, Swiss_Prot_Human, neXtProt_list, RefSeq_list)


# Flatten the background_cleaned_IDs list to then add to our data frame
flattened_background_cleaned_IDs <- sapply(background_cleaned_IDs, function(x) paste(x, collapse = ","))

tyrosines_containing_background$cleaned_protein_IDs <- flattened_background_cleaned_IDs
# filter to only include rows with SwissProt Entry hits
tyrosines_containing_background_inSwissProt <- tyrosines_containing_background[tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]
# Then write the data frame to a file
write.table(tyrosines_containing_background_inSwissProt, file = "../out/medium_bins/phosphotyrosine_containing_background_inSwissProt.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# also write the ones with no hit
tyrosines_containing_background_UNMATCHED <- tyrosines_containing_background[!tyrosines_containing_background$cleaned_protein_IDs %in% Swiss_Prot_Human$Entry,]


write.table(tyrosines_containing_background_UNMATCHED, file = "../out/medium_bins/phosphotyrosine_containing_background_UNMATCHED.tsv", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

```

```{r cluster_profiler_enrichment_analysis}
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(devtools)
# library(BiocFileCache)
# library(dbplyr)
# need to downgrade devtools for biomart to work #stackoverflow
# devtools::install_version("dbplyr", version = "2.3.4")


## convert the SwissProt IDs to Ensembl gene IDs
# Connect to the Ensembl database
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# Get the corresponding Entrez IDs for all UniProt IDs that we can
Uniprot = getBM(
  attributes=c('ensembl_gene_id','uniprotswissprot'), 
  mart = ensembl)

# 85 of our background IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)

# subset to only include these who do
background <- tyrosines_containing_background_inSwissProt[tyrosines_containing_background_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]

# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(background$cleaned_protein_IDs, Uniprot$uniprotswissprot)

# Extract corresponding ENSEMBL Gene IDs
background_genes <- Uniprot$ensembl_gene_id[matched_indices]

# Remove NAs if any (in case some SwissProt IDs didn't have a match)
background_genes <- na.omit(background_genes)

# do same with foreground

# subset to only include these who do
foreground <- tyrosines_containing_foreground_inSwissProt[tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot,]

# Match SwissProt IDs in the Uniprot data frame to get the position index
matched_indices <- match(foreground$cleaned_protein_IDs, Uniprot$uniprotswissprot)

# Extract corresponding ENSEMBL Gene IDs
foreground_genes <- Uniprot$ensembl_gene_id[matched_indices]

# Remove NAs if any (in case some SwissProt IDs didn't have a match)
foreground_genes <- na.omit(foreground_genes)

# 0 of our foreground IDs do not have an ENSEMBL gene ID (via biomart):
sum(!tyrosines_containing_foreground_inSwissProt$cleaned_protein_IDs %in% Uniprot$uniprotswissprot)

#### now we have the input for cluster profiler. lets run the GO term enrichment analysis as per the omics course: 

cluster_GO_MF <- enrichGO(gene         = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 0.5,
                       qvalueCutoff = 1)


########### now for molecular function
GO_term_dataframe_MF <- as.data.frame(cluster_GO_MF)
goplot(cluster_GO_MF)  
barplot(cluster_GO_MF)


cluster_GO_CC <- enrichGO(gene         = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "CC",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 1,
                       qvalueCutoff = 1)

GO_term_dataframe_CC <- as.data.frame(cluster_GO_CC)

goplot(cluster_GO_CC)  
barplot(cluster_GO_CC)

######### now for biological processes 
cluster_GO_BP <- enrichGO(gene         = foreground_genes,
                       universe     = background_genes,
                       OrgDb        = org.Hs.eg.db,  # human annotation
                       keyType      = "ENSEMBL", #just to make sure
                       ont          = "BP",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
                       pAdjustMethod = "BH", # Benjamini-Hochberg
                       pvalueCutoff = 1,
                       qvalueCutoff = 1)

GO_term_dataframe_BP <- as.data.frame(cluster_GO_BP)

goplot(cluster_GO_BP)  
barplot(cluster_GO_BP)


############# BELOW CONCERNS FIXED - I HAD PREVIOUSLY SELECTE DTHE BACKGROUND INCORRECTLY AS PHOSPHOTYROSINE-CONTAINING peptides only!; fixed using correct grepl regex
# ## uhhh, our data frame is empty so we get no significant results! 
# 
# # a few things to consideR: 
# # Foreground vs background is quite large. 500 vs 1500 sp only 3x smaller than background! 
# 
# ## just as a little test/play around - what if we look at all ENSEMBL IDs that have a UniProt ID hit
# background_very_broad <- Uniprot$ensembl_gene_id[Uniprot$uniprotswissprot != ""]
# 
# 
# cluster_GO_very_broad <- enrichGO(gene         = foreground_genes,
#                        universe     = background_very_broad,
#                        OrgDb        = org.Hs.eg.db,  # human annotation
#                        keyType      = "ENSEMBL", #just to make sure
#                        ont          = "MF",  # For Biological Process; can use "MF" for Molecular Function or "CC" for Cellular Component
#                        pAdjustMethod = "BH", # Benjamini-Hochberg
#                        pvalueCutoff = 0.05,
#                        qvalueCutoff = 0.05)
# 
# GO_term_dataframe_very_broad <- as.data.frame(cluster_GO_very_broad)
# 
# 
# goplot(cluster_GO_very_broad) 
# 
# # we get some significant results but this si too broad a background! 

```

```{r treeplot_attempt}
library(GOSemSim)
library(enrichplot)

# NB: treeplot might not be a good choice as we have a small number of enriched terms!
# Use function 'godata' to create a GO similarity data object
# since BP had no significant hits lets only do it for MF; CC only had 3 GO terms
GO_similarity_MF <- godata('org.Hs.eg.db', ont="MF")

#to have treeplots work these edits need to be made to installation 
# install.packages("ggnewscale")
# devtools::install_version("tidytree", version = "0.4.2")



### to fix Error in offspring.tbl_tree_item(.data = .data, .node = .node, tiponly = tiponly,  : could not find function "offspring.tbl_tree_item" I copied this solution from: https://github.com/YuLab-SMU/enrichplot/issues/249
nodeid.tbl_tree <- utils::getFromNamespace("nodeid.tbl_tree", "tidytree")
rootnode.tbl_tree <- utils::getFromNamespace("rootnode.tbl_tree", "tidytree")
offspring.tbl_tree <- utils::getFromNamespace("offspring.tbl_tree", "tidytree")
offspring.tbl_tree_item <- utils::getFromNamespace(".offspring.tbl_tree_item", "tidytree")
child.tbl_tree <- utils::getFromNamespace("child.tbl_tree", "tidytree")
parent.tbl_tree <- utils::getFromNamespace("parent.tbl_tree", "tidytree")

# Add similarity matrix to the enrichment result
cluster_GO_tree <- pairwise_termsim(cluster_GO_MF, method = "Wang", semData = GO_similarity_MF)
treeplot(cluster_GO_tree)


```

```{r KEGG pathway enrichment}
# I might need entrez IDs, otherwise I get NULL
library(biomaRt)
library(ggplot2)
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

foreground_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                           filters = 'ensembl_gene_id',
                           values = foreground_genes,
                           mart = ensembl)

background_entrez <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                           filters = 'ensembl_gene_id',
                           values = background_genes,
                           mart = ensembl)

# make sure to convert to character too!
foreground_entrez_ids <- as.character(na.omit(foreground_entrez$entrezgene_id))
background_entrez_ids <- as.character(na.omit(background_entrez$entrezgene_id))
## this has cut down our background list to 4833 from 14633!
## foreground less affected and reduced from 492 to 412


kegg_enrichment <- enrichKEGG(
gene = foreground_entrez_ids,
universe = background_entrez_ids,
organism = 'hsa',
pvalueCutoff = 1, ##changed so the top 2 hits would appear; this is adjusted p value!
qvalueCutoff = 1 # this does not affect anything
)
# dotplot(kegg_enrichment, showCategory = 10, font.size = 8)
# Error in ans[ypos] <- rep(yes, length.out = len)[ypos] : 
#   replacement has length zero
## we get no significant hits unless we adjust the cutoffs lets look at the results

dotplot(kegg_enrichment, showCategory = 10, font.size = 8) # returns only top 2
# effectively I want to get all with p value < 0.05 even if it's not corrected,
# but only 2 have q value of < 0.5 rest are fixed at ~ 0.95

# do dotplot manually
# extract df
KEGG_df <- kegg_enrichment@result
# filter down to just p<0.05
KEGG_Significant_Pathways <- KEGG_df[KEGG_df$pvalue <0.1,]
names(KEGG_Significant_Pathways)

# convert gene ratios to numbers

KEGG_Significant_Pathways$GeneRatio <- sapply(strsplit(KEGG_Significant_Pathways$GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))


ggplot(KEGG_Significant_Pathways, aes(y = reorder(Description, -pvalue), x = GeneRatio)) +
  geom_point(aes(size = Count, color = pvalue)) +
  scale_color_gradient(low = "red", high = "blue") +
  labs(y = "Description", x = "Gene Ratio", color = "pvalue", size = "Count") +
  theme_bw() +
  theme(
    legend.position = "right",
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    plot.title = element_text(hjust = 0.5)
  ) +
  ggtitle("KEGG Pathways with p<0.05")
ggsave("../out/medium_bins/KEGG_dotplot_bw_phosphotyrosinesonly.png", plot = last_plot(), width = 6, height = 4, dpi = 300)

```

```{r Reactome_ORA}
library(ReactomePA)


reactome_ORA <- enrichPathway(gene=foreground_entrez_ids,
universe=background_entrez_ids,
pvalueCutoff = 1, readable=TRUE)
#no hits at pcutoff 0.05
head(reactome_ORA)
#even at cutoff 1 we get nothing. how is this possible? Could the genes in my
# fore and background just not be part of REACTOME?


```

```{r PHOSPHOTYROSINE_ONLY}
# what if we tried phosphotyrosines only for foreground and background:
phosphotyrosine_foreg <- foreground[grepl("Y2", foreground$peptidoform_id), ]
phosphotyrosine_backg <- background[grepl("Y2", background$peptidoform_id), ]

# this is 74 vs 1408 observations # hold on! 1408 is the same as we had before! 
# I have forgotten to correctly filter my background and have only selected
# phosphotyrosines,

# make sure no bias in inclusion criteria
# phosphotyrosine-containing peptidoforms - grab all associated protein IDs across all bins as a background? 
# vs foreground just the ones in the correct bin
# if indeed sulfo, we would get an enrichment in cytokines, secreted proteins, membrane proteins, or similar

# if random there should be no significant hits

# try also running for a different bin with a similar number of hits as the expected sulfo bin. 





# 5) bin matches to libraries of transmembrane and secreted proteins: 

# 5_1) how many of all peptides have IDs in any of these categories for all bins? 
# THIS is probably not very usefun info actually...

# 5_2) how many Tyrosine-containng are trans-memeb and how many are secreted (as proportion?) 

# 5_3) how many phospho-tryosine containing ones are secreted/transmemb? 

#### could our data suggest sulfation of other amino acids at all? 

```
